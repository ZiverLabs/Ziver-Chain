# src/contracts/wallet.zx
# Ziver Multi-Chain Wallet Smart Contract

use { Crypto } from "../core/crypto.zx"

entity ZiverWallet:
    owner: Address
    balances: Map<text, integer>  # chain -> balance
    tokens: Map<text, Map<text, integer>>  # chain -> token_address -> balance
    supported_chains: List<text> = ["ZIVER", "ETHEREUM", "BSC", "TON"]
    guardians: List<Address>
    recovery_threshold: integer = 2
    
    action constructor(initial_owner: Address):
        """
        Initialize wallet with owner
        """
        self.owner = initial_owner
        self.balances["ZIVER"] = 0
        self.balances["ETHEREUM"] = 0  
        self.balances["BSC"] = 0
        self.balances["TON"] = 0
        
        print "üëõ Wallet created for: " + initial_owner
    
    action deposit(chain: text, amount: integer) -> boolean:
        """
        Deposit native currency to wallet
        """
        if not self.supported_chains.contains(chain):
            print "‚ùå Unsupported chain: " + chain
            return false
        
        if amount <= 0:
            print "‚ùå Invalid amount"
            return false
        
        self.balances[chain] = (self.balances[chain] ?? 0) + amount
        print "üí∞ Deposited " + string(amount) + " to " + chain + " chain"
        
        return true
    
    action withdraw(chain: text, amount: integer, to: Address) -> boolean:
        """
        Withdraw native currency from wallet
        """
        if not self.supported_chains.contains(chain):
            print "‚ùå Unsupported chain: " + chain
            return false
        
        let current_balance = self.balances[chain] ?? 0
        if current_balance < amount:
            print "‚ùå Insufficient balance on " + chain + " chain"
            return false
        
        # Verify sender is owner (in real implementation, check signature)
        if context.caller != self.owner:
            print "‚ùå Only owner can withdraw"
            return false
        
        self.balances[chain] = current_balance - amount
        print "üí∏ Withdrew " + string(amount) + " from " + chain + " chain to " + to
        
        return true
    
    action store_token(chain: text, token_address: text, amount: integer) -> boolean:
        """
        Store token from any supported chain
        """
        if not self.supported_chains.contains(chain):
            print "‚ùå Unsupported chain: " + chain
            return false
        
        if not self.tokens.has(chain):
            self.tokens[chain] = {}
        
        let current_amount = self.tokens[chain][token_address] ?? 0
        self.tokens[chain][token_address] = current_amount + amount
        
        print "ü™ô Stored token " + token_address + " on " + chain + " chain: " + string(amount)
        return true
    
    action get_token_balance(chain: text, token_address: text) -> integer:
        """
        Get token balance for specific chain
        """
        if not self.tokens.has(chain):
            return 0
        
        return self.tokens[chain][token_address] ?? 0
    
    action get_balance(chain: text) -> integer:
        """
        Get native currency balance for specific chain
        """
        return self.balances[chain] ?? 0
    
    action get_total_portfolio_value() -> Map<text, integer>:
        """
        Get total portfolio value across all chains
        """
        let portfolio = {}
        
        for each chain in self.supported_chains:
            let native_balance = self.balances[chain] ?? 0
            let token_balance = 0
            
            if self.tokens.has(chain):
                for each token_amount in self.tokens[chain].values():
                    token_balance += token_amount
            
            portfolio[chain] = native_balance + token_balance
        
        return portfolio
    
    action add_guardian(guardian: Address):
        """
        Add recovery guardian
        """
        if context.caller != self.owner:
            print "‚ùå Only owner can add guardians"
            return
        
        if not self.guardians.contains(guardian):
            self.guardians.add(guardian)
            print "üõ°Ô∏è Guardian added: " + guardian
    
    action recover_wallet(new_owner: Address, guardian_signatures: List<text>) -> boolean:
        """
        Recover wallet with guardian approval
        """
        if guardian_signatures.count() < self.recovery_threshold:
            print "‚ùå Insufficient guardian signatures"
            return false
        
        # Verify guardian signatures (simplified)
        let valid_signatures = 0
        for each signature in guardian_signatures:
            # In real implementation, verify each signature
            valid_signatures += 1
        
        if valid_signatures >= self.recovery_threshold:
            self.owner = new_owner
            print "üîì Wallet recovered by new owner: " + new_owner
            return true
        
        return false
    
    action bridge_assets(source_chain: text, target_chain: text, amount: integer, token_address: text?) -> boolean:
        """
        Bridge assets between chains
        """
        if not self.supported_chains.contains(source_chain) or not self.supported_chains.contains(target_chain):
            print "‚ùå Unsupported chain"
            return false
        
        if token_address:
            # Bridge token
            let current_balance = self.get_token_balance(source_chain, token_address)
            if current_balance < amount:
                print "‚ùå Insufficient token balance"
                return false
            
            # Lock tokens on source chain
            self.tokens[source_chain][token_address] = current_balance - amount
            
            # Mint on target chain (would call bridge contract)
            self.store_token(target_chain, token_address, amount)
            
            print "üåâ Bridged token " + token_address + ": " + source_chain + " ‚Üí " + target_chain
        else:
            # Bridge native currency
            let current_balance = self.balances[source_chain] ?? 0
            if current_balance < amount:
                print "‚ùå Insufficient native balance"
                return false
            
            self.balances[source_chain] = current_balance - amount
            self.balances[target_chain] = (self.balances[target_chain] ?? 0) + amount
            
            print "üåâ Bridged native currency: " + source_chain + " ‚Üí " + target_chain
        
        return true

# Test the wallet
print "üëõ Testing Multi-Chain Wallet..."
let wallet = ZiverWallet("ZIV_user_123")

# Test deposits
wallet.deposit("ZIVER", 1000)
wallet.deposit("ETHEREUM", 500)

# Test token storage
wallet.store_token("ETHEREUM", "0xUSDT", 1500)
wallet.store_token("BSC", "0xBUSD", 2000)

# Check balances
print "ZIVER Balance: " + string(wallet.get_balance("ZIVER"))
print "ETH USDT Balance: " + string(wallet.get_token_balance("ETHEREUM", "0xUSDT"))

# Test portfolio
let portfolio = wallet.get_total_portfolio_value()
print "üìä Total Portfolio: " + string(portfolio)
