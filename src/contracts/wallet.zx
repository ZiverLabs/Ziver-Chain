# src/contracts/wallet.zx
# Ziver Multi-Chain Wallet Smart Contract

contract ZiverWallet {
    persistent storage owner: string
    persistent storage balances: map
    persistent storage tokens: map
    persistent storage supported_chains: list
    persistent storage guardians: list
    persistent storage recovery_threshold: integer = 2

    action init(initial_owner: string) {
        """
        Initialize wallet with owner
        """
        this.owner = initial_owner
        this.balances = {
            "ZIVER": 0,
            "ETHEREUM": 0,  
            "BSC": 0,
            "TON": 0
        }
        this.tokens = {}
        this.supported_chains = ["ZIVER", "ETHEREUM", "BSC", "TON"]
        this.guardians = []

        print("üëõ Wallet created for: " + initial_owner)
    }

    action deposit(chain: string, amount: integer) -> boolean {
        """
        Deposit native currency to wallet
        """
        if not this.supported_chains.contains(chain) {
            print("‚ùå Unsupported chain: " + chain)
            return false
        }

        if amount <= 0 {
            print("‚ùå Invalid amount")
            return false
        }

        this.balances[chain] = this.balances.get(chain, 0) + amount
        print("üí∞ Deposited " + string(amount) + " to " + chain + " chain")

        return true
    }

    action withdraw(chain: string, amount: integer, to: string) -> boolean {
        """
        Withdraw native currency from wallet
        """
        if not this.supported_chains.contains(chain) {
            print("‚ùå Unsupported chain: " + chain)
            return false
        }

        let current_balance = this.balances.get(chain, 0)
        if current_balance < amount {
            print("‚ùå Insufficient balance on " + chain + " chain")
            return false
        }

        // Verify sender is owner (in real implementation, check signature)
        let caller = "context.caller"  // Would be actual caller in production
        if caller != this.owner {
            print("‚ùå Only owner can withdraw")
            return false
        }

        this.balances[chain] = current_balance - amount
        print("üí∏ Withdrew " + string(amount) + " from " + chain + " chain to " + to)

        return true
    }

    action store_token(chain: string, token_address: string, amount: integer) -> boolean {
        """
        Store token from any supported chain
        """
        if not this.supported_chains.contains(chain) {
            print("‚ùå Unsupported chain: " + chain)
            return false
        }

        if not this.tokens.has(chain) {
            this.tokens[chain] = {}
        }

        let chain_tokens = this.tokens[chain]
        let current_amount = chain_tokens.get(token_address, 0)
        chain_tokens[token_address] = current_amount + amount

        print("ü™ô Stored token " + token_address + " on " + chain + " chain: " + string(amount))
        return true
    }

    action get_token_balance(chain: string, token_address: string) -> integer {
        """
        Get token balance for specific chain
        """
        if not this.tokens.has(chain) {
            return 0
        }

        let chain_tokens = this.tokens[chain]
        return chain_tokens.get(token_address, 0)
    }

    action get_balance(chain: string) -> integer {
        """
        Get native currency balance for specific chain
        """
        return this.balances.get(chain, 0)
    }

    action get_total_portfolio_value() -> map {
        """
        Get total portfolio value across all chains
        """
        let portfolio = {}

        for each chain in this.supported_chains {
            let native_balance = this.balances.get(chain, 0)
            let token_balance = 0

            if this.tokens.has(chain) {
                let chain_tokens = this.tokens[chain]
                for each token_address, token_amount in chain_tokens {
                    token_balance += token_amount
                }
            }

            portfolio[chain] = native_balance + token_balance
        }

        return portfolio
    }

    action add_guardian(guardian: string) {
        """
        Add recovery guardian
        """
        let caller = "context.caller"  // Would be actual caller in production
        if caller != this.owner {
            print("‚ùå Only owner can add guardians")
            return
        }

        if not this.guardians.contains(guardian) {
            this.guardians.push(guardian)
            print("üõ°Ô∏è Guardian added: " + guardian)
        }
    }

    action recover_wallet(new_owner: string, guardian_signatures: list) -> boolean {
        """
        Recover wallet with guardian approval
        """
        if guardian_signatures.count() < this.recovery_threshold {
            print("‚ùå Insufficient guardian signatures")
            return false
        }

        // Verify guardian signatures (simplified)
        let valid_signatures = 0
        for each signature in guardian_signatures {
            // In real implementation, verify each signature
            valid_signatures += 1
        }

        if valid_signatures >= this.recovery_threshold {
            this.owner = new_owner
            print("üîì Wallet recovered by new owner: " + new_owner)
            return true
        }

        return false
    }

    action bridge_assets(source_chain: string, target_chain: string, amount: integer, token_address: string?) -> boolean {
        """
        Bridge assets between chains
        """
        if not this.supported_chains.contains(source_chain) or not this.supported_chains.contains(target_chain) {
            print("‚ùå Unsupported chain")
            return false
        }

        if token_address != null {
            // Bridge token
            let current_balance = this.get_token_balance(source_chain, token_address)
            if current_balance < amount {
                print("‚ùå Insufficient token balance")
                return false
            }

            // Lock tokens on source chain
            let source_tokens = this.tokens.get(source_chain, {})
            source_tokens[token_address] = current_balance - amount
            this.tokens[source_chain] = source_tokens

            // Mint on target chain (would call bridge contract)
            this.store_token(target_chain, token_address, amount)

            print("üåâ Bridged token " + token_address + ": " + source_chain + " ‚Üí " + target_chain)
        } else {
            // Bridge native currency
            let current_balance = this.balances.get(source_chain, 0)
            if current_balance < amount {
                print("‚ùå Insufficient native balance")
                return false
            }

            this.balances[source_chain] = current_balance - amount
            this.balances[target_chain] = this.balances.get(target_chain, 0) + amount

            print("üåâ Bridged native currency: " + source_chain + " ‚Üí " + target_chain)
        }

        return true
    }
}

// Test the wallet
action test_multi_chain_wallet() {
    print("üëõ Testing Multi-Chain Wallet...")
    let wallet = ZiverWallet{}
    wallet.init("ZIV_user_123")

    // Test deposits
    wallet.deposit("ZIVER", 1000)
    wallet.deposit("ETHEREUM", 500)

    // Test token storage
    wallet.store_token("ETHEREUM", "0xUSDT", 1500)
    wallet.store_token("BSC", "0xBUSD", 2000)

    // Check balances
    print("ZIVER Balance: " + string(wallet.get_balance("ZIVER")))
    print("ETH USDT Balance: " + string(wallet.get_token_balance("ETHEREUM", "0xUSDT")))

    // Test portfolio
    let portfolio = wallet.get_total_portfolio_value()
    print("üìä Total Portfolio: " + string(portfolio))
}

export {
    ZiverWallet,
    test_multi_chain_wallet
}