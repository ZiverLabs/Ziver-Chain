# src/contracts/wallet.zx
# Ziver Multi-Chain Wallet Smart Contract

contract ZiverWallet {
    # REQUIRED: Contract name field
    name: "ZiverWallet"
    version: "1.0.0"
    
    persistent storage owner: string
    persistent storage balances: map
    persistent storage tokens: map
    persistent storage supported_chains: list
    persistent storage guardians: list
    persistent storage recovery_threshold: integer = 2

    action init(initial_owner: string) {
        """
        Initialize wallet with owner
        """
        this.owner = initial_owner
        this.balances = {
            "ZIVER": 0,
            "ETHEREUM": 0,  
            "BSC": 0,
            "TON": 0
        }
        this.tokens = {}
        this.supported_chains = ["ZIVER", "ETHEREUM", "BSC", "TON"]
        this.guardians = []

        print("üëõ Wallet created for: " + initial_owner)
    }

    action deposit(chain: string, amount: integer) -> boolean {
        """
        Deposit native currency to wallet
        """
        if not this.supported_chains.contains(chain) {
            print("‚ùå Unsupported chain: " + chain)
            return false
        }

        if amount <= 0 {
            print("‚ùå Invalid amount")
            return false
        }

        this.balances[chain] = this.balances.get(chain, 0) + amount
        print("üí∞ Deposited " + string(amount) + " to " + chain + " chain")

        return true
    }

    action withdraw(chain: string, amount: integer, to: string) -> boolean {
        """
        Withdraw native currency from wallet
        """
        if not this.supported_chains.contains(chain) {
            print("‚ùå Unsupported chain: " + chain)
            return false
        }

        let current_balance = this.balances.get(chain, 0)
        if current_balance < amount {
            print("‚ùå Insufficient balance on " + chain + " chain")
            return false
        }

        # In production: verify signature
        # For now, we'll trust the initiator
        # let caller = msg.sender  # Would use actual caller in production
        # if caller != this.owner {
        #     print("‚ùå Only owner can withdraw")
        #     return false
        # }

        this.balances[chain] = current_balance - amount
        print("üí∏ Withdrew " + string(amount) + " from " + chain + " chain to " + to)

        return true
    }

    action store_token(chain: string, token_address: string, amount: integer) -> boolean {
        """
        Store token from any supported chain
        """
        if not this.supported_chains.contains(chain) {
            print("‚ùå Unsupported chain: " + chain)
            return false
        }

        if not this.tokens.has(chain) {
            this.tokens[chain] = {}
        }

        let chain_tokens = this.tokens[chain]
        let current_amount = chain_tokens.get(token_address, 0)
        chain_tokens[token_address] = current_amount + amount

        print("ü™ô Stored token " + token_address + " on " + chain + " chain: " + string(amount))
        return true
    }

    action get_token_balance(chain: string, token_address: string) -> integer {
        """
        Get token balance for specific chain
        """
        if not this.tokens.has(chain) {
            return 0
        }

        let chain_tokens = this.tokens[chain]
        return chain_tokens.get(token_address, 0)
    }

    action get_balance(chain: string) -> integer {
        """
        Get native currency balance for specific chain
        """
        return this.balances.get(chain, 0)
    }

    action get_total_portfolio_value() -> map {
        """
        Get total portfolio value across all chains
        """
        let portfolio = {}

        for each chain in this.supported_chains {
            let native_balance = this.balances.get(chain, 0)
            let token_balance = 0

            if this.tokens.has(chain) {
                let chain_tokens = this.tokens[chain]
                for each token_address, token_amount in chain_tokens {
                    token_balance += token_amount
                }
            }

            portfolio[chain] = native_balance + token_balance
        }

        return portfolio
    }

    action add_guardian(guardian: string) {
        """
        Add recovery guardian
        """
        # In production: verify owner signature
        # if msg.sender != this.owner {
        #     print("‚ùå Only owner can add guardians")
        #     return
        # }

        if not this.guardians.contains(guardian) {
            this.guardians.push(guardian)
            print("üõ°Ô∏è Guardian added: " + guardian)
        }
    }

    action recover_wallet(new_owner: string, guardian_signatures: list) -> boolean {
        """
        Recover wallet with guardian approval
        """
        if guardian_signatures.count() < this.recovery_threshold {
            print("‚ùå Insufficient guardian signatures")
            return false
        }

        # Verify guardian signatures (simplified for now)
        let valid_signatures = 0
        for each signature in guardian_signatures {
            # In real implementation, verify each signature
            valid_signatures += 1
        }

        if valid_signatures >= this.recovery_threshold {
            this.owner = new_owner
            print("üîì Wallet recovered by new owner: " + new_owner)
            return true
        }

        return false
    }

    action bridge_assets(source_chain: string, target_chain: string, amount: integer, token_address: string?) -> boolean {
        """
        Bridge assets between chains
        """
        if not this.supported_chains.contains(source_chain) or not this.supported_chains.contains(target_chain) {
            print("‚ùå Unsupported chain")
            return false
        }

        if token_address != null {
            # Bridge token
            let current_balance = this.get_token_balance(source_chain, token_address)
            if current_balance < amount {
                print("‚ùå Insufficient token balance")
                return false
            }

            # Lock tokens on source chain
            let source_tokens = this.tokens.get(source_chain, {})
            source_tokens[token_address] = current_balance - amount
            this.tokens[source_chain] = source_tokens

            # Mint on target chain (simulated)
            this.store_token(target_chain, token_address, amount)

            print("üåâ Bridged token " + token_address + ": " + source_chain + " ‚Üí " + target_chain)
        } else {
            # Bridge native currency
            let current_balance = this.balances.get(source_chain, 0)
            if current_balance < amount {
                print("‚ùå Insufficient native balance")
                return false
            }

            this.balances[source_chain] = current_balance - amount
            this.balances[target_chain] = this.balances.get(target_chain, 0) + amount

            print("üåâ Bridged native currency: " + source_chain + " ‚Üí " + target_chain)
        }

        return true
    }
}

# Create and export the contract instance
let wallet_instance = ZiverWallet()
export default wallet_instance

# Alternative: If you need to export multiple things:
# export {
#     ZiverWallet as contract,
#     test_multi_chain_wallet as test
# }