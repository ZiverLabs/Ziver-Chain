# src/contracts/token_standard.zx
# ZRC-20 Token Standard (Ziver's equivalent of ERC-20)

entity ZRC20Token:
    name: text
    symbol: text
    decimals: integer = 18
    total_supply: integer
    balances: Map<Address, integer>
    allowances: Map<Address, Map<Address, integer>>
    owner: Address
    
    # Events (would be emitted in real implementation)
    action Transfer(from: Address, to: Address, value: integer):
        print "ðŸ”„ Transfer: " + from + " â†’ " + to + " (" + string(value) + ")"
    
    action Approval(owner: Address, spender: Address, value: integer):
        print "âœ… Approval: " + owner + " allows " + spender + " to spend " + string(value)
    
    action constructor(token_name: text, token_symbol: text, initial_supply: integer, token_owner: Address):
        """
        Initialize token
        """
        self.name = token_name
        self.symbol = token_symbol
        self.total_supply = initial_supply
        self.owner = token_owner
        self.balances[token_owner] = initial_supply
        
        print "ðŸª™ Token created: " + token_name + " (" + token_symbol + ")"
        print "  Total Supply: " + string(initial_supply)
        print "  Owner: " + token_owner
        
        # Emit transfer for initial supply
        self.Transfer("0x0", token_owner, initial_supply)
    
    action transfer(to: Address, value: integer) -> boolean:
        """
        Transfer tokens to another address
        """
        let from = context.caller
        let from_balance = self.balances[from] ?? 0
        
        if from_balance < value:
            print "âŒ Insufficient balance"
            return false
        
        if value <= 0:
            print "âŒ Invalid amount"
            return false
        
        # Update balances
        self.balances[from] = from_balance - value
        self.balances[to] = (self.balances[to] ?? 0) + value
        
        # Emit event
        self.Transfer(from, to, value)
        
        return true
    
    action transfer_from(from: Address, to: Address, value: integer) -> boolean:
        """
        Transfer tokens on behalf of another address
        """
        let spender = context.caller
        let from_balance = self.balances[from] ?? 0
        let allowance = self.allowances[from][spender] ?? 0
        
        if from_balance < value:
            print "âŒ Insufficient balance"
            return false
        
        if allowance < value:
            print "âŒ Insufficient allowance"
            return false
        
        # Update balances and allowance
        self.balances[from] = from_balance - value
        self.balances[to] = (self.balances[to] ?? 0) + value
        self.allowances[from][spender] = allowance - value
        
        # Emit event
        self.Transfer(from, to, value)
        
        return true
    
    action approve(spender: Address, value: integer) -> boolean:
        """
        Approve spender to transfer tokens
        """
        let owner = context.caller
        
        if not self.allowances.has(owner):
            self.allowances[owner] = {}
        
        self.allowances[owner][spender] = value
        
        # Emit event
        self.Approval(owner, spender, value)
        
        return true
    
    action balance_of(owner: Address) -> integer:
        """
        Get token balance of address
        """
        return self.balances[owner] ?? 0
    
    action allowance(owner: Address, spender: Address) -> integer:
        """
        Get remaining allowance
        """
        if not self.allowances.has(owner):
            return 0
        
        return self.allowances[owner][spender] ?? 0
    
    action mint(to: Address, value: integer) -> boolean:
        """
        Mint new tokens (only owner)
        """
        if context.caller != self.owner:
            print "âŒ Only owner can mint"
            return false
        
        self.total_supply += value
        self.balances[to] = (self.balances[to] ?? 0) + value
        
        # Emit transfer from zero address (minting)
        self.Transfer("0x0", to, value)
        
        print "ðŸ†• Minted " + string(value) + " tokens to " + to
        return true
    
    action burn(value: integer) -> boolean:
        """
        Burn tokens
        """
        let from = context.caller
        let from_balance = self.balances[from] ?? 0
        
        if from_balance < value:
            print "âŒ Insufficient balance to burn"
            return false
        
        self.total_supply -= value
        self.balances[from] = from_balance - value
        
        # Emit transfer to zero address (burning)
        self.Transfer(from, "0x0", value)
        
        print "ðŸ”¥ Burned " + string(value) + " tokens from " + from
        return true

# Test the token standard
print "ðŸª™ Testing ZRC-20 Token Standard..."
let my_token = ZRC20Token("Ziver Test Token", "ZTT", 1000000, "ZIV_owner_123")

# Test transfers
my_token.transfer("ZIV_user_456", 500)
my_token.approve("ZIV_spender_789", 300)

# Check balances
print "Owner balance: " + string(my_token.balance_of("ZIV_owner_123"))
print "User balance: " + string(my_token.balance_of("ZIV_user_456"))