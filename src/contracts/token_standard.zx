# src/contracts/token_standard.zx
# ZRC-20 Token Standard (Ziver's equivalent of ERC-20)

contract ZRC20Token {
    persistent storage name: string
    persistent storage symbol: string
    persistent storage decimals: integer = 18
    persistent storage total_supply: integer
    persistent storage balances: map
    persistent storage allowances: map
    persistent storage owner: string

    action init(token_name: string, token_symbol: string, initial_supply: integer, token_owner: string) {
        """
        Initialize token
        """
        this.name = token_name
        this.symbol = token_symbol
        this.total_supply = initial_supply
        this.owner = token_owner
        this.balances[token_owner] = initial_supply
        this.allowances = {}

        print("ðŸª™ Token created: " + token_name + " (" + token_symbol + ")")
        print("  Total Supply: " + string(initial_supply))
        print("  Owner: " + token_owner)

        // Emit transfer for initial supply
        this.Transfer("0x0", token_owner, initial_supply)
    }

    action transfer(to: string, value: integer) -> boolean {
        """
        Transfer tokens to another address
        """
        let from = "context.caller"  // Would be actual caller in production
        let from_balance = this.balances.get(from, 0)

        if from_balance < value {
            print("âŒ Insufficient balance")
            return false
        }

        if value <= 0 {
            print("âŒ Invalid amount")
            return false
        }

        // Update balances
        this.balances[from] = from_balance - value
        this.balances[to] = this.balances.get(to, 0) + value

        // Emit event
        this.Transfer(from, to, value)

        return true
    }

    action transfer_from(from: string, to: string, value: integer) -> boolean {
        """
        Transfer tokens on behalf of another address
        """
        let spender = "context.caller"  // Would be actual caller in production
        let from_balance = this.balances.get(from, 0)
        let allowance_map = this.allowances.get(from, {})
        let allowance = allowance_map.get(spender, 0)

        if from_balance < value {
            print("âŒ Insufficient balance")
            return false
        }

        if allowance < value {
            print("âŒ Insufficient allowance")
            return false
        }

        // Update balances and allowance
        this.balances[from] = from_balance - value
        this.balances[to] = this.balances.get(to, 0) + value
        
        allowance_map[spender] = allowance - value
        this.allowances[from] = allowance_map

        // Emit event
        this.Transfer(from, to, value)

        return true
    }

    action approve(spender: string, value: integer) -> boolean {
        """
        Approve spender to transfer tokens
        """
        let owner = "context.caller"  // Would be actual caller in production

        if not this.allowances.has(owner) {
            this.allowances[owner] = {}
        }

        let owner_allowances = this.allowances[owner]
        owner_allowances[spender] = value

        // Emit event
        this.Approval(owner, spender, value)

        return true
    }

    action balance_of(owner: string) -> integer {
        """
        Get token balance of address
        """
        return this.balances.get(owner, 0)
    }

    action allowance(owner: string, spender: string) -> integer {
        """
        Get remaining allowance
        """
        if not this.allowances.has(owner) {
            return 0
        }

        let owner_allowances = this.allowances[owner]
        return owner_allowances.get(spender, 0)
    }

    action mint(to: string, value: integer) -> boolean {
        """
        Mint new tokens (only owner)
        """
        let caller = "context.caller"  // Would be actual caller in production
        if caller != this.owner {
            print("âŒ Only owner can mint")
            return false
        }

        this.total_supply += value
        this.balances[to] = this.balances.get(to, 0) + value

        // Emit transfer from zero address (minting)
        this.Transfer("0x0", to, value)

        print("ðŸ†• Minted " + string(value) + " tokens to " + to)
        return true
    }

    action burn(value: integer) -> boolean {
        """
        Burn tokens
        """
        let from = "context.caller"  // Would be actual caller in production
        let from_balance = this.balances.get(from, 0)

        if from_balance < value {
            print("âŒ Insufficient balance to burn")
            return false
        }

        this.total_supply -= value
        this.balances[from] = from_balance - value

        // Emit transfer to zero address (burning)
        this.Transfer(from, "0x0", value)

        print("ðŸ”¥ Burned " + string(value) + " tokens from " + from)
        return true
    }

    // Events (would be emitted in real implementation)
    action Transfer(from: string, to: string, value: integer) {
        print("ðŸ”„ Transfer: " + from + " â†’ " + to + " (" + string(value) + ")")
    }

    action Approval(owner: string, spender: string, value: integer) {
        print("âœ… Approval: " + owner + " allows " + spender + " to spend " + string(value))
    }
}

// Test the token standard
action test_zrc20_token_standard() {
    print("ðŸª™ Testing ZRC-20 Token Standard...")
    let my_token = ZRC20Token{}
    my_token.init("Ziver Test Token", "ZTT", 1000000, "ZIV_owner_123")

    // Test transfers
    my_token.transfer("ZIV_user_456", 500)
    my_token.approve("ZIV_spender_789", 300)

    // Check balances
    print("Owner balance: " + string(my_token.balance_of("ZIV_owner_123")))
    print("User balance: " + string(my_token.balance_of("ZIV_user_456")))
}

export {
    ZRC20Token,
    test_zrc20_token_standard
}