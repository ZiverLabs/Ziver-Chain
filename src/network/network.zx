# src/network/network.zx
use "crypto" as crypto
use "datetime" as datetime

// Advanced P2P Network Layer with Multi-Chain Support
protocol P2PNetworkProtocol {
    action start_node(port: integer, network_type: string) -> boolean
    action connect_to_peer(address: string, chain_type: string) -> boolean
    action broadcast_block(block: any, chain_type: string) -> boolean
    action broadcast_transaction(tx: any, chain_type: string) -> boolean
    action discover_peers(network_type: string) -> list
}

contract P2PNetwork implements P2PNetworkProtocol {
    persistent storage peers: map
    persistent storage node_id: string
    persistent storage port: integer?
    persistent storage is_listening: boolean = false
    persistent storage message_queue: list
    persistent storage chain_connections: map

    entity Peer {
        address: string
        chain_type: string
        last_seen: integer
        connection_score: float = 1.0
        latency: integer = 0
        is_connected: boolean = false
    }

    action init(node_id: string) {
        this.node_id = node_id
        this.peers = {}
        this.message_queue = []
        this.chain_connections = {
            "ZIVER": [],
            "ETHEREUM": [],
            "TON": [],
            "BSC": [],
            "POLYGON": []
        }
    }

    action start_node(port: integer, network_type: string = "mainnet") -> boolean {
        this.port = port
        this.is_listening = true

        print("üîÑ Starting P2P node on port " + string(port))
        print("Node ID: " + this.node_id)
        print("Network: " + network_type)
        print("üì° Listening for peers...")

        // Start background services
        spawn this.start_message_processor()
        spawn this.start_peer_discovery()
        spawn this.start_health_monitor()

        // Connect to bootstrap nodes
        this.connect_to_bootstrap_nodes(network_type)

        return true
    }

    action connect_to_peer(address: string, chain_type: string = "ZIVER") -> boolean {
        let peer_id = chain_type + "_" + address

        if this.peers.has(peer_id) {
            print("‚ö†Ô∏è Already connected to peer: " + address)
            return true
        }

        print("üîó Connecting to " + chain_type + " peer: " + address)

        let peer = Peer{
            address: address,
            chain_type: chain_type,
            last_seen: datetime.now().timestamp(),
            is_connected: true
        }

        this.peers[peer_id] = peer
        this.chain_connections[chain_type].push(peer_id)

        print("‚úÖ Connected to " + string(this.get_connected_peers_count()) + " peers across " + 
              string(this.get_active_chains_count()) + " chains")

        return true
    }

    action broadcast_block(block: any, chain_type: string = "ZIVER") -> boolean {
        let target_peers = this.get_peers_by_chain(chain_type)

        print("üì¢ Broadcasting " + chain_type + " block #" + string(block.index) + 
              " to " + string(target_peers.count()) + " peers")

        let success_count = 0
        for each peer_id in target_peers {
            let peer = this.peers[peer_id]
            if this.send_block_to_peer(peer, block) {
                success_count += 1
            }
        }

        print("‚úÖ Successfully broadcast to " + string(success_count) + "/" + 
              string(target_peers.count()) + " peers")

        return success_count > 0
    }

    action broadcast_transaction(tx: any, chain_type: string = "ZIVER") -> boolean {
        let target_peers = this.get_peers_by_chain(chain_type)

        print("üí∏ Broadcasting " + chain_type + " transaction to " + 
              string(target_peers.count()) + " peers")

        let success_count = 0
        for each peer_id in target_peers {
            let peer = this.peers[peer_id]
            if this.send_transaction_to_peer(peer, tx) {
                success_count += 1
            }
        }

        // Also broadcast to bridge nodes for cross-chain transactions
        if this.is_cross_chain_transaction(tx) {
            spawn this.broadcast_to_bridge_nodes(tx)
        }

        return success_count > 0
    }

    action discover_peers(network_type: string = "mainnet") -> list {
        print("üîç Discovering peers on " + network_type + " network...")

        let discovered_peers = []

        // DNS-based discovery
        let dns_peers = this.discover_via_dns(network_type)
        discovered_peers = discovered_peers.concat(dns_peers)

        // Peer exchange with existing peers
        let exchanged_peers = this.exchange_peers_with_connected()
        discovered_peers = discovered_peers.concat(exchanged_peers)

        // Bootstrap nodes for the network
        let bootstrap_peers = this.get_bootstrap_nodes(network_type)
        discovered_peers = discovered_peers.concat(bootstrap_peers)

        // Remove duplicates
        discovered_peers = this.deduplicate_peers(discovered_peers)

        print("üéØ Discovered " + string(discovered_peers.count()) + " potential peers")

        return discovered_peers
    }

    // Enhanced Network Methods
    action send_block_to_peer(peer: Peer, block: any) -> boolean {
        try {
            print("  üì¶ Sending block #" + string(block.index) + " to " + peer.address)

            // Update peer metrics
            peer.last_seen = datetime.now().timestamp()
            peer.connection_score = math.min(1.0, peer.connection_score + 0.01)

            return true
        } catch(error) {
            print("‚ùå Failed to send block to " + peer.address + ": " + string(error))
            peer.connection_score = math.max(0.0, peer.connection_score - 0.1)
            return false
        }
    }

    action send_transaction_to_peer(peer: Peer, tx: any) -> boolean {
        try {
            print("  üí∏ Sending transaction to " + peer.address)

            // Update peer metrics
            peer.last_seen = datetime.now().timestamp()

            return true
        } catch(error) {
            print("‚ùå Failed to send transaction to " + peer.address)
            return false
        }
    }

    action async start_message_processor() {
        print("üîÑ Starting advanced message processor...")

        while this.is_listening {
            // Process incoming messages
            if not this.message_queue.is_empty() {
                let message = this.message_queue.shift()
                this.process_incoming_message(message)
            }

            // Small delay to prevent busy waiting
            await sleep(0.1)
        }
    }

    action async start_peer_discovery() {
        print("üîÑ Starting continuous peer discovery...")

        while this.is_listening {
            let new_peers = this.discover_peers()
            for each peer_info in new_peers {
                if not this.peers.has(peer_info.id) {
                    this.connect_to_peer(peer_info.address, peer_info.chain_type)
                }
            }

            // Discover every 5 minutes
            await sleep(300)
        }
    }

    action async start_health_monitor() {
        print("üîÑ Starting network health monitor...")

        while this.is_listening {
            this.check_peer_health()
            this.cleanup_dead_peers()

            // Check every minute
            await sleep(60)
        }
    }

    action check_peer_health() {
        let current_time = datetime.now().timestamp()

        for each peer_id, peer in this.peers {
            let time_since_seen = current_time - peer.last_seen

            if time_since_seen > 300 { // 5 minutes
                peer.connection_score -= 0.05
                print("‚ö†Ô∏è Peer " + peer.address + " inactive for " + string(time_since_seen) + "s")
            }

            if peer.connection_score < 0.3 {
                print("üî¥ Unhealthy peer: " + peer.address + " (score: " + string(peer.connection_score) + ")")
            }
        }
    }

    action cleanup_dead_peers() {
        let dead_peers = []

        for each peer_id, peer in this.peers {
            if peer.connection_score <= 0.1 {
                dead_peers.push(peer_id)
            }
        }

        for each dead_peer in dead_peers {
            print("üßπ Removing dead peer: " + this.peers[dead_peer].address)
            this.peers.delete(dead_peer)
        }
    }

    // Helper Methods
    action get_peers_by_chain(chain_type: string) -> list {
        return this.chain_connections.get(chain_type, [])
    }

    action get_connected_peers_count() -> integer {
        let count = 0
        for each peer_id, peer in this.peers {
            if peer.is_connected {
                count += 1
            }
        }
        return count
    }

    action get_active_chains_count() -> integer {
        let count = 0
        for each chain_type, peers in this.chain_connections {
            if not peers.is_empty() {
                count += 1
            }
        }
        return count
    }

    action connect_to_bootstrap_nodes(network_type: string) {
        let bootstrap_nodes = this.get_bootstrap_nodes(network_type)

        for each node in bootstrap_nodes {
            spawn this.connect_to_peer(node.address, node.chain_type)
        }
    }

    action get_bootstrap_nodes(network_type: string) -> list {
        match network_type {
            case "mainnet":
                return [
                    {"address": "mainnet.ziver.io:30303", "chain_type": "ZIVER"},
                    {"address": "bootnode1.ziver.io:30303", "chain_type": "ZIVER"},
                    {"address": "bootnode2.ziver.io:30303", "chain_type": "ZIVER"}
                ]
            case "testnet":
                return [
                    {"address": "testnet.ziver.io:30304", "chain_type": "ZIVER"},
                    {"address": "bootnode1.test.ziver.io:30304", "chain_type": "ZIVER"}
                ]
            default:
                return []
        }
    }

    action discover_via_dns(network_type: string) -> list {
        // DNS-based peer discovery implementation
        return [
            {"address": "dns-peer1.ziver.io:30303", "chain_type": "ZIVER", "id": "dns1"},
            {"address": "dns-peer2.ziver.io:30303", "chain_type": "ZIVER", "id": "dns2"}
        ]
    }

    action exchange_peers_with_connected() -> list {
        // Peer exchange protocol implementation
        let exchanged_peers = []
        
        for each peer_id, peer in this.peers {
            if peer.is_connected {
                // Simulate getting peer list from connected peer
                exchanged_peers.push({
                    "address": "exchanged_" + peer.address,
                    "chain_type": peer.chain_type,
                    "id": "ex_" + peer_id
                })
            }
        }
        
        return exchanged_peers
    }

    action deduplicate_peers(peers: list) -> list {
        let unique_peers = []
        let seen = {}

        for each peer in peers {
            let key = peer.address + "_" + peer.chain_type
            if not seen.has(key) {
                seen[key] = true
                unique_peers.push(peer)
            }
        }

        return unique_peers
    }

    action process_incoming_message(message: map) {
        match message.type {
            case "block":
                this.handle_incoming_block(message.data)
            case "transaction":
                this.handle_incoming_transaction(message.data)
            case "peer_list":
                this.handle_peer_list(message.data)
            case "ping":
                this.handle_ping(message.data)
            default:
                print("‚ùì Unknown message type: " + message.type)
        }
    }

    action handle_incoming_block(block_data: map) {
        print("üì• Received block #" + string(block_data.index) + " from peer")
        // Would validate and process the block
    }

    action handle_incoming_transaction(tx_data: map) {
        print("üì• Received transaction from peer")
        // Would validate and add to mempool
    }

    action handle_peer_list(peer_list: list) {
        print("üì• Received peer list with " + string(peer_list.count()) + " peers")
        for each peer_info in peer_list {
            this.connect_to_peer(peer_info.address, peer_info.chain_type)
        }
    }

    action handle_ping(ping_data: map) {
        print("üèì Received ping from " + ping_data.sender)
        // Would respond with pong
    }

    action is_cross_chain_transaction(tx: any) -> boolean {
        return tx.data != null and tx.data.contains("cross_chain")
    }

    action async broadcast_to_bridge_nodes(tx: any) {
        print("üåâ Broadcasting to bridge nodes for cross-chain transaction")
        // Would send to bridge nodes for cross-chain processing
        await sleep(1) // Simulate async operation
    }

    // Built-in sleep function for async operations
    action async sleep(seconds: float) {
        // Built-in async sleep implementation
    }
}

// Test Enhanced Network
action async test_enhanced_network() {
    print("üåê Testing Enhanced P2P Network...")

    let network = P2PNetwork(node_id: "node_001")

    // Start node on mainnet
    if network.start_node(8545, "mainnet") {
        print("‚úÖ Node started successfully")

        // Test peer discovery
        let discovered_peers = network.discover_peers("mainnet")
        print("Discovered peers: " + string(discovered_peers.count()))

        // Test multi-chain connections
        await network.connect_to_peer("eth-node.example.com:30303", "ETHEREUM")
        await network.connect_to_peer("ton-node.example.com:30000", "TON")

        // Test broadcasting
        let test_block = {"index": 1, "hash": "test_hash_123"}
        network.broadcast_block(test_block, "ZIVER")

        let test_tx = {"hash": "tx_test_456", "value": 100}
        network.broadcast_transaction(test_tx, "ZIVER")
    }
}

export {
    P2PNetwork,
    P2PNetworkProtocol,
    test_enhanced_network
}