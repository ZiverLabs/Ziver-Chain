# src/core/crypto.zx
# Quantum-Resistant Cryptography Module for Ziver Chain
# Phase 0 rewrite — Zexus v1.8.2 compatible
#
# Layout order (per R-012/R-013/R-014):
#   1. Imports & constants
#   2. Protocol
#   3. Helper actions (module-level)
#   4. Contract (single state field only)
#   5. Module-level state variables (after contract)
#   6. Entities (after contract)
#   7. Test function
#   8. Exports

use "crypto" as crypto_lib
use "datetime" as dt
use "math" as math

// ─── Constants ───

const CRYPTO_POLICIES = {
    "min_key_strength": 2048,
    "max_key_age_days": 365,
    "signature_timeout_seconds": 300,
    "hash_algorithm": "SHA3-512",
    "quantum_safe_threshold": 2030
}

// ─── Protocol ───

protocol QuantumResistantCrypto {
    action generate_quantum_keypair(algorithm)
    action generate_hybrid_keypair()
    action quantum_sign(message, private_key, context)
    action quantum_verify(message, sig_obj, public_key)
    action validate_key_strength(public_key)
}

// ─── Helper actions (module-level, no state) ───

action keccak256(data) {
    return crypto_lib.keccak256(data)
}

action sha256(data) {
    return hash(data)
}

action double_keccak(data) {
    return crypto_lib.keccak256(crypto_lib.keccak256(data))
}

action sign_message(message, private_key) {
    return signature(message, private_key)
}

action verify_message(sig_val, message, public_key) {
    return verify_sig(sig_val, message, public_key)
}

action generate_keypair_simple() {
    return crypto_lib.generateKeypair()
}

action derive_address(public_key, chain_type) {
    let h = crypto_lib.keccak256(public_key)
    if chain_type == "ZIVER" {
        return "ZIV_" + h
    }
    if chain_type == "ETHEREUM" {
        return "0x" + h
    }
    if chain_type == "TON" {
        return "EQ" + h
    }
    return "ZIV_" + h
}

action calculate_merkle_root(tx_list) {
    if len(tx_list) == 0 {
        return crypto_lib.keccak256("empty_merkle_root")
    }

    let hashes = []
    for each tx in tx_list {
        let tx_content = string(tx)
        hashes.push(crypto_lib.keccak256(tx_content))
    }

    while len(hashes) > 1 {
        let new_level = []
        let i = 0
        while i < len(hashes) {
            if i + 1 < len(hashes) {
                new_level.push(crypto_lib.keccak256(hashes[i] + hashes[i + 1]))
                i = i + 2
            } else {
                new_level.push(crypto_lib.keccak256(hashes[i] + hashes[i]))
                i = i + 1
            }
        }
        hashes = new_level
    }

    return hashes[0]
}

// ─── QuantumCrypto contract (single state field per R-013) ───

contract QuantumCrypto implements QuantumResistantCrypto {
    state {
        initialized: 0
    }

    action init() {
        this.initialized = 1
    }

    action generate_quantum_keypair(algorithm) {
        let algo = "ECDSA_SECP256K1"
        if algorithm != null {
            algo = algorithm
        }

        let timestamp = dt.timestamp()
        let raw_kp = crypto_lib.generateKeypair()

        let addr_hash = crypto_lib.keccak256(raw_kp.public_key)
        let address = "ZIV_Q_" + algo + "_" + addr_hash

        let expires_at = timestamp + (365 * 24 * 60 * 60)

        let key_strength = 256
        if algo == "RSA_4096" {
            key_strength = 4096
        }
        if algo == "ED25519" {
            key_strength = 128
        }

        let qkp = KeyPair{
            public_key: raw_kp.public_key,
            private_key: raw_kp.private_key,
            address: address,
            key_type: algo,
            key_strength: key_strength,
            created_at: timestamp,
            expires_at: expires_at,
            status: "active",
            rotation_count: 0
        }

        let key_id = "KEY_" + crypto_lib.keccak256(raw_kp.public_key)

        // R-015: push BEFORE map assignment
        _key_registry_keys.push(key_id)
        _key_registry[key_id] = qkp
        _total_keys = _total_keys + 1

        audit("quantum_keypair_generated", {
            "key_id": key_id,
            "algorithm": algo,
            "address": address,
            "timestamp": timestamp
        })

        return qkp
    }

    action generate_hybrid_keypair() {
        let classical = crypto_lib.generateKeypair()
        let quantum = crypto_lib.generateKeypair()

        let combined_hash = crypto_lib.keccak256(classical.public_key + quantum.public_key)
        let combined_address = "ZIV_HYBRID_" + combined_hash

        let timestamp = dt.timestamp()

        let hybrid = HybridKeyPair{
            classical_public: classical.public_key,
            classical_private: classical.private_key,
            quantum_public: quantum.public_key,
            quantum_private: quantum.private_key,
            combined_address: combined_address,
            security_level: "quantum_resistant",
            created_at: timestamp
        }

        audit("hybrid_keypair_generated", {
            "combined_address": combined_address,
            "timestamp": timestamp
        })

        return hybrid
    }

    action quantum_sign(message, private_key, context) {
        verify(message != null, "Message cannot be empty")
        verify(private_key != null, "Private key required")

        let timestamp = dt.timestamp()
        _signature_count = _signature_count + 1
        let nonce_val = _signature_count

        let message_with_context = message
        let context_hash = ""
        if context != null {
            context_hash = crypto_lib.keccak256(string(context))
            message_with_context = message + "|" + context_hash
        }

        let signing_data = message_with_context + "|" + string(timestamp) + "|" + string(nonce_val)
        let sig_val = signature(signing_data, private_key)

        let qsig = QuantumSignature{
            sig: sig_val,
            timestamp: timestamp,
            nonce: nonce_val,
            algorithm: "ECDSA_WITH_TIMESTAMP",
            context_hash: context_hash
        }

        return qsig
    }

    action quantum_verify(message, sig_obj, public_key) {
        try {
            verify(sig_obj != null, "Signature required")
            verify(public_key != null, "Public key required")

            let message_with_context = message
            if sig_obj.context_hash != null {
                let ch = sig_obj.context_hash
                if len(ch) > 0 {
                    message_with_context = message + "|" + ch
                }
            }

            let signing_data = message_with_context + "|" + string(sig_obj.timestamp) + "|" + string(sig_obj.nonce)
            let is_valid = verify_sig(sig_obj.sig, signing_data, public_key)

            let current_time = dt.timestamp()
            let time_diff = current_time - sig_obj.timestamp
            let confidence = 100.0
            if time_diff > 60 {
                confidence = confidence - ((time_diff - 60) * 0.1)
            }
            if confidence < 0 {
                confidence = 0.0
            }

            let warns = []
            if time_diff > CRYPTO_POLICIES["signature_timeout_seconds"] {
                warns.push("Signature timestamp is too old")
            }

            return VerificationResult{
                valid: is_valid,
                confidence: confidence,
                warnings: warns,
                details: "time_diff=" + string(time_diff)
            }

        } catch (error) {
            return VerificationResult{
                valid: false,
                confidence: 0.0,
                warnings: ["Verification error: " + string(error)],
                details: string(error)
            }
        }
    }

    action validate_key_strength(public_key) {
        let weaknesses = []
        let recommendations = []
        let score = 100.0

        let key_length = len(public_key)
        if key_length < 64 {
            weaknesses.push("Key too short")
            score = score - 30
            recommendations.push("Generate longer key")
        }

        let level = "classical"
        if score >= 90 {
            level = "quantum_safe"
        }
        if score >= 70 {
            if score < 90 {
                level = "post_quantum"
            }
        }
        if score < 50 {
            level = "weak"
        }

        return SecurityRating{
            level: level,
            score: score,
            weaknesses: weaknesses,
            recommendations: recommendations
        }
    }

    action rotate_keys(key_id, new_algorithm) {
        let old_key = _key_registry[key_id]
        if old_key == null {
            throw "Key not found: " + key_id
        }

        let new_kp = this.generate_quantum_keypair(new_algorithm)

        audit("key_rotated", {
            "old_key_id": key_id,
            "new_algorithm": new_algorithm,
            "timestamp": dt.timestamp()
        })

        return new_kp
    }

    action get_total_keys() {
        return _total_keys
    }

    action get_signature_count() {
        return _signature_count
    }

    action get_key(key_id) {
        return _key_registry[key_id]
    }

    action get_all_key_ids() {
        return _key_registry_keys
    }
}

// ─── Module-level state (after contract per R-014) ───

let _key_registry = {}
let _key_registry_keys = []
let _signature_count = 0
let _total_keys = 0

// ─── Entities (after contract per R-012) ───

entity KeyPair {
    public_key: "",
    private_key: "",
    address: "",
    key_type: "ECDSA_SECP256K1",
    key_strength: 256,
    created_at: 0,
    expires_at: 0,
    status: "active",
    rotation_count: 0
}

entity HybridKeyPair {
    classical_public: "",
    classical_private: "",
    quantum_public: "",
    quantum_private: "",
    combined_address: "",
    security_level: "quantum_resistant",
    created_at: 0
}

entity QuantumSignature {
    sig: "",
    timestamp: 0,
    nonce: 0,
    algorithm: "",
    context_hash: ""
}

entity VerificationResult {
    valid: false,
    confidence: 0.0,
    warnings: [],
    details: ""
}

entity SecurityRating {
    level: "classical",
    score: 0.0,
    weaknesses: [],
    recommendations: []
}

// ─── Test ───

action test_quantum_crypto() {
    print("=== Testing Crypto Module v2.0 ===")

    try {
        let qc = QuantumCrypto{}
        qc.init()

        // Keypair generation
        let kp = qc.generate_quantum_keypair("ECDSA_SECP256K1")
        print("[OK] Keypair generated - address: " + kp.address)
        print("  key_type: " + kp.key_type)

        // Hybrid keypair
        let hybrid = qc.generate_hybrid_keypair()
        print("[OK] Hybrid keypair - address: " + hybrid.combined_address)

        // Sign
        let msg = "Hello Ziver Chain v2.0!"
        let sig_obj = qc.quantum_sign(msg, kp.private_key, null)
        print("[OK] Signed - nonce: " + string(sig_obj.nonce))

        // Verify
        let result = qc.quantum_verify(msg, sig_obj, kp.public_key)
        print("[OK] Verified - valid: " + string(result.valid))
        print("  confidence: " + string(result.confidence))

        // Key strength
        let rating = qc.validate_key_strength(kp.public_key)
        print("[OK] Key rating: " + rating.level + " (score=" + string(rating.score) + ")")

        // Helpers
        let h = keccak256("test")
        print("[OK] keccak256: " + h)
        let h2 = sha256("test")
        print("[OK] sha256: " + h2)

        // State
        print("[OK] Total keys: " + string(qc.get_total_keys()))
        print("[OK] Sig count: " + string(qc.get_signature_count()))
        print("[OK] Key ids: " + string(qc.get_all_key_ids()))

        print("=== Crypto Tests PASSED ===")

    } catch (error) {
        print("[FAIL] " + string(error))
    }
}

// ─── Exports ───

export {
    QuantumCrypto,
    QuantumResistantCrypto,
    KeyPair,
    HybridKeyPair,
    QuantumSignature,
    VerificationResult,
    SecurityRating,
    CRYPTO_POLICIES,
    keccak256,
    sha256,
    double_keccak,
    sign_message,
    verify_message,
    generate_keypair_simple,
    derive_address,
    calculate_merkle_root,
    test_quantum_crypto
}
