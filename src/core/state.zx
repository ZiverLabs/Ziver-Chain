# src/core/state.zx
# Self-Evolving State Management for Ziver Chain
# Phase 0 rewrite — Zexus v1.8.2 compatible
#
# Layout: imports, constants, protocol, helpers, contract,
#   module-level state, entities, test, exports

use "crypto" as crypto
use "datetime" as dt
use "math" as math

// ─── Constants ───

const STATE_POLICIES = {
    "max_parameter_change_percentage": 0.2,
    "min_approval_confidence": 0.8,
    "emergency_change_threshold": 0.9,
    "change_cooldown_period": 3600,
    "rollback_window": 86400,
    "audit_trail_retention": 30
}

const DEFAULT_PARAMETERS = {
    "block_time_target": 2.0,
    "block_gas_limit": 8000000,
    "max_block_size": 1048576,
    "difficulty_adjustment_window": 100,
    "validator_min_stake": 1000,
    "validator_max_count": 100,
    "consensus_timeout": 30,
    "network_propagation_delay": 2,
    "max_peer_connections": 50,
    "peer_discovery_interval": 300,
    "transaction_fee_base": 100,
    "transaction_fee_multiplier": 1.0,
    "block_reward": 1000,
    "reward_halving_interval": 210000,
    "inflation_rate": 0.02,
    "max_validator_slash_percentage": 0.1,
    "min_security_deposit": 10000,
    "proposal_quorum": 0.6,
    "voting_period": 604800,
    "execution_delay": 86400,
    "emergency_threshold": 0.8
}

// ─── Protocol ───

protocol SelfEvolvingProtocol {
    action propose_parameter_adjustment(param_name, new_value, reason, proposed_by)
    action review_pending_adjustments()
    action get_network_health()
    // rollback_parameter moved to module-level due to R-018
    action get_state_history()
    action validate_state_integrity()
    action get_parameter(param_name)
    action set_parameter(param_name, value)
}

// ─── Helper actions ───

action calculate_change_pct(old_val, new_val) {
    let old_f = old_val + 0.0
    let new_f = new_val + 0.0
    if old_f == 0.0 {
        if new_f == 0.0 {
            return 0.0
        }
        return 1.0
    }
    let diff = new_f - old_f
    if diff < 0 {
        diff = 0.0 - diff
    }
    return diff / old_f
}

action make_proposal(id, param_name, old_val, new_val, change_pct, reason, proposed_by, timestamp) {
    return {
        "id": id,
        "parameter": param_name,
        "old_value": old_val,
        "new_value": new_val,
        "change_percentage": change_pct,
        "reason": reason,
        "proposed_by": proposed_by,
        "proposed_at": timestamp,
        "ai_confidence": 0.0,
        "status": "pending"
    }
}

action make_snapshot(id, parameters_copy, timestamp, reason, hash_val) {
    return {
        "snapshot_id": id,
        "parameters": parameters_copy,
        "timestamp": timestamp,
        "reason": reason,
        "hash": hash_val
    }
}

// ─── SelfEvolvingState Contract ───

contract SelfEvolvingState implements SelfEvolvingProtocol {
    state {
        initialized: 0
    }

    action init() {
        this.initialized = 1
    }

    action get_parameter(param_name) {
        return _parameters[param_name]
    }

    action set_parameter(param_name, value) {
        let old_val = _parameters[param_name]

        // R-015: push BEFORE map assignment
        _adjustment_history.push({
            "parameter": param_name,
            "old_value": old_val,
            "new_value": value,
            "timestamp": dt.timestamp(),
            "applied_by": "direct_set"
        })

        // Map assignment AFTER push
        _parameters[param_name] = value

        audit("parameter_set", {
            "parameter": param_name,
            "old_value": string(old_val),
            "new_value": string(value),
            "timestamp": dt.timestamp()
        })

        return true
    }

    action propose_parameter_adjustment(param_name, new_value, reason, proposed_by) {
        let old_val = _parameters[param_name]
        if old_val == null {
            throw "Unknown parameter: " + param_name
        }
        verify(new_value != null, "New value is required")
        verify(reason != null, "Reason is required")

        let change_pct = calculate_change_pct(old_val, new_value)

        let max_change = STATE_POLICIES["max_parameter_change_percentage"]
        if change_pct > max_change {
            throw "Change exceeds maximum allowed: " + string(change_pct)
        }

        // Check cooldown
        let last_change = _last_change_times[param_name]
        if last_change != null {
            let elapsed = dt.timestamp() - last_change
            let cooldown = STATE_POLICIES["change_cooldown_period"]
            if elapsed < cooldown {
                throw "Parameter change cooldown active"
            }
        }

        let timestamp = dt.timestamp()
        _proposal_counter = _proposal_counter + 1
        let proposal_id = "PROP_" + crypto.keccak256(param_name + string(new_value) + string(timestamp))

        let proposal = make_proposal(
            proposal_id, param_name, old_val, new_value,
            change_pct, reason, proposed_by, timestamp
        )

        // For Phase 0: auto-apply safe proposals (low change %)
        if change_pct < 0.1 {
            // R-015: push BEFORE all map/property assignments
            _adjustment_history.push({
                "proposal_id": proposal_id,
                "parameter": param_name,
                "old_value": old_val,
                "new_value": new_value,
                "timestamp": timestamp,
                "applied_by": proposed_by
            })

            // Map assignments AFTER push
            _parameters[param_name] = new_value
            proposal["status"] = "applied"
            _last_change_times[param_name] = timestamp

            audit("parameter_adjusted", {
                "proposal_id": proposal_id,
                "parameter": param_name,
                "change_pct": change_pct,
                "timestamp": timestamp
            })

            return { "proposal_id": proposal_id, "status": "applied" }
        }

        // Add to pending for review
        _pending_adjustments.push(proposal)
        return { "proposal_id": proposal_id, "status": "pending_review" }
    }

    action review_pending_adjustments() {
        let applied_count = 0
        let rejected_count = 0
        let still_pending = []

        let idx = 0
        while idx < len(_pending_adjustments) {
            let proposal = _pending_adjustments[idx]
            idx = idx + 1

            let time_since = dt.timestamp() - proposal["proposed_at"]
            if time_since < 300 {
                still_pending.push(proposal)
                continue
            }

            // Auto-approve after review period if change is moderate
            let change_pct = proposal["change_percentage"]
            if change_pct <= STATE_POLICIES["max_parameter_change_percentage"] {
                let pname = proposal["parameter"]
                let new_val = proposal["new_value"]
                // R-015: push BEFORE map assignments
                _adjustment_history.push({
                    "proposal_id": proposal["id"],
                    "parameter": pname,
                    "old_value": proposal["old_value"],
                    "new_value": new_val,
                    "timestamp": dt.timestamp(),
                    "applied_by": "review_system"
                })
                _parameters[pname] = new_val
                proposal["status"] = "applied"
                applied_count = applied_count + 1
            } else {
                proposal["status"] = "rejected"
                rejected_count = rejected_count + 1
            }
        }

        _pending_adjustments = still_pending

        return {
            "pending_count": len(still_pending),
            "applied_count": applied_count,
            "rejected_count": rejected_count,
            "timestamp": dt.timestamp()
        }
    }

    action take_state_snapshot(reason) {
        let timestamp = dt.timestamp()

        // Copy via helper to isolate map assignments (R-015)
        let params_copy = copy_current_parameters(_parameter_keys, _parameters)

        let snapshot_data = string(params_copy) + string(timestamp) + reason
        let hash_val = crypto.keccak256(snapshot_data)

        _snapshot_counter = _snapshot_counter + 1
        let snapshot_id = "SNAP_" + string(_snapshot_counter)

        let snapshot = make_snapshot(snapshot_id, params_copy, timestamp, reason, hash_val)

        // R-015: push before map
        _snapshot_keys.push(snapshot_id)
        _snapshots[snapshot_id] = snapshot

        return snapshot_id
    }

    // rollback_parameter removed — use module-level rollback_parameter() instead (R-018)

    action get_network_health() {
        let active_params = len(_parameter_keys)
        let history_size = len(_adjustment_history)
        let pending_count = len(_pending_adjustments)
        let snapshot_count = len(_snapshot_keys)

        let health_score = 100.0
        if pending_count > 10 {
            health_score = health_score - 10.0
        }
        if history_size > 1000 {
            health_score = health_score - 5.0
        }

        return {
            "overall_health": health_score,
            "active_parameters": active_params,
            "adjustment_history_size": history_size,
            "pending_adjustments": pending_count,
            "snapshot_count": snapshot_count,
            "timestamp": dt.timestamp()
        }
    }

    action get_state_history() {
        return _adjustment_history
    }

    action validate_state_integrity() {
        let issues = []

        // Check all parameter keys have values
        let idx = 0
        while idx < len(_parameter_keys) {
            let key = _parameter_keys[idx]
            let val = _parameters[key]
            if val == null {
                issues.push("Missing value for: " + key)
            }
            idx = idx + 1
        }

        // Check snapshot chain
        let snap_idx = 0
        while snap_idx < len(_snapshot_keys) {
            let sid = _snapshot_keys[snap_idx]
            let snap = _snapshots[sid]
            if snap == null {
                issues.push("Missing snapshot: " + sid)
            }
            snap_idx = snap_idx + 1
        }

        let valid = len(issues) == 0
        return {
            "valid": valid,
            "issues": issues,
            "parameters_checked": len(_parameter_keys),
            "snapshots_checked": len(_snapshot_keys),
            "timestamp": dt.timestamp()
        }
    }

    action get_all_parameters() {
        return _parameters
    }

    action get_parameter_count() {
        return len(_parameter_keys)
    }

    action get_snapshot_count() {
        return len(_snapshot_keys)
    }

    action get_adjustment_count() {
        return len(_adjustment_history)
    }
}

// ─── Module-level state (after contract per R-014) ───

let _parameter_keys = [
    "block_time_target",
    "block_gas_limit",
    "max_block_size",
    "difficulty_adjustment_window",
    "validator_min_stake",
    "validator_max_count",
    "consensus_timeout",
    "network_propagation_delay",
    "max_peer_connections",
    "peer_discovery_interval",
    "transaction_fee_base",
    "transaction_fee_multiplier",
    "block_reward",
    "reward_halving_interval",
    "inflation_rate",
    "max_validator_slash_percentage",
    "min_security_deposit",
    "proposal_quorum",
    "voting_period",
    "execution_delay",
    "emergency_threshold"
]

let _parameters = {
    "block_time_target": 2.0,
    "block_gas_limit": 8000000,
    "max_block_size": 1048576,
    "difficulty_adjustment_window": 100,
    "validator_min_stake": 1000,
    "validator_max_count": 100,
    "consensus_timeout": 30,
    "network_propagation_delay": 2,
    "max_peer_connections": 50,
    "peer_discovery_interval": 300,
    "transaction_fee_base": 100,
    "transaction_fee_multiplier": 1.0,
    "block_reward": 1000,
    "reward_halving_interval": 210000,
    "inflation_rate": 0.02,
    "max_validator_slash_percentage": 0.1,
    "min_security_deposit": 10000,
    "proposal_quorum": 0.6,
    "voting_period": 604800,
    "execution_delay": 86400,
    "emergency_threshold": 0.8
}

let _adjustment_history = []
let _pending_adjustments = []
let _snapshots = {}
let _snapshot_keys = []
let _last_change_times = {}
let _proposal_counter = 0
let _snapshot_counter = 0

// ─── Module-level helpers (after let vars so they can access them) ───

action copy_current_parameters(keys, params) {
    let result = {}
    let idx = 0
    while idx < len(keys) {
        let key = keys[idx]
        result[key] = params[key]
        idx = idx + 1
    }
    return result
}

action _do_rollback(param_name, snapshot_id) {
    let snapshot = _snapshots[snapshot_id]
    if snapshot == null {
        return null
    }
    let params_data = snapshot["parameters"]
    let target_value = params_data[param_name]
    if target_value == null {
        return null
    }
    let old_val = _parameters[param_name]

    // R-015: push BEFORE map assignment
    _adjustment_history.push({
        "type": "rollback",
        "parameter": param_name,
        "old_value": old_val,
        "new_value": target_value,
        "timestamp": dt.timestamp()
    })

    // Map assignment AFTER push
    _parameters[param_name] = target_value

    return {
        "success": true,
        "parameter": param_name,
        "old_value": old_val,
        "new_value": target_value
    }
}

// Module-level rollback function (R-018: can't call state-modifying helpers from contract methods)
action rollback_parameter(param_name, snapshot_id) {
    let result = _do_rollback(param_name, snapshot_id)
    if result == null {
        throw "Rollback failed: snapshot or parameter not found"
    }
    return result
}

// ─── Entities (after contract per R-012) ───

entity ParameterProposal {
    id: "",
    parameter: "",
    old_value: 0,
    new_value: 0,
    change_percentage: 0.0,
    reason: "",
    proposed_by: "",
    proposed_at: 0,
    ai_confidence: 0.0,
    status: "pending"
}

entity ParameterAdjustment {
    proposal_id: "",
    parameter: "",
    old_value: 0,
    new_value: 0,
    applied_by: "",
    applied_at: 0,
    confirmed: false
}

entity NetworkHealth {
    timestamp: 0,
    overall_health: 0.0,
    active_parameters: 0,
    pending_adjustments: 0,
    snapshot_count: 0
}

// ─── Test ───

action test_state_module() {
    print("=== Testing State Module v2.0 ===")

    try {
        let state = SelfEvolvingState{}
        state.init()

        // Test 1: parameter access
        let block_time = state.get_parameter("block_time_target")
        print("[1] block_time_target: " + string(block_time))

        // Test 2: parameter count
        let param_count = state.get_parameter_count()
        print("[2] Parameter count: " + string(param_count))

        // Test 3: set parameter
        state.set_parameter("block_time_target", 3.0)
        let updated = state.get_parameter("block_time_target")
        print("[3] Updated block_time_target: " + string(updated))

        // Test 4: adjustment count after set
        let adj1 = state.get_adjustment_count()
        print("[4] Adjustment count after set: " + string(adj1))

        // Test 5: proposal (small change, auto-applied)
        let result = state.propose_parameter_adjustment(
            "block_reward", 1050, "Slight increase for testing", "admin"
        )
        print("[5] Proposal status: " + result["status"])

        // Test 6: adjustment count after proposal
        let adj2 = state.get_adjustment_count()
        print("[6] Adjustment count after propose: " + string(adj2))

        // Test 7: snapshot
        let snap_id = state.take_state_snapshot("test_snapshot")
        print("[7] Snapshot ID: " + string(snap_id))

        // Test 8: snapshot count
        let snap_count = state.get_snapshot_count()
        print("[8] Snapshot count: " + string(snap_count))

        // Test 9: integrity
        let integrity = state.validate_state_integrity()
        print("[9] State integrity valid: " + string(integrity["valid"]))

        // Test 10: health
        let health = state.get_network_health()
        print("[10] Network health: " + string(health["overall_health"]))

        // Test 11: rollback using module-level function (R-018 workaround)
        state.set_parameter("block_time_target", 5.0)
        let rb_result = rollback_parameter("block_time_target", snap_id)
        let rolled = state.get_parameter("block_time_target")
        print("[11] After rollback block_time: " + string(rolled))

        // Take post-rollback snapshot explicitly (self-call removed from rollback method)
        let snap2 = state.take_state_snapshot("post_rollback")

        // Test 12: final counts
        let final_adj = state.get_adjustment_count()
        let final_snap = state.get_snapshot_count()
        print("[12] Final adjustments: " + string(final_adj) + " snapshots: " + string(final_snap))

        print("=== State Tests PASSED ===")

    } catch (error) {
        print("[FAIL] " + string(error))
    }
}

// ─── Exports ───

export {
    SelfEvolvingState,
    SelfEvolvingProtocol,
    ParameterProposal,
    ParameterAdjustment,
    NetworkHealth,
    STATE_POLICIES,
    DEFAULT_PARAMETERS,
    calculate_change_pct,
    make_proposal,
    make_snapshot,
    copy_current_parameters,
    test_state_module
}
