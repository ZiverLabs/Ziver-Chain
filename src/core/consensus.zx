# src/core/consensus.zx
use "crypto" as crypto
use "datetime" as datetime
use "math" as math
use "../database/postgres" as db
use "../middleware/security_middleware" as security

// Enable memory tracking
track_memory()

// Security policies for consensus
const CONSENSUS_POLICIES = {
    min_stake: 1000,
    max_validators: 100,
    block_time_target: 15, // seconds
    slash_percentage: 0.01, // 1% slashing for misbehavior
    reward_distribution_delay: 100 // blocks
}

// Throttle consensus operations
throttle("validator_selection", { requests_per_minute: 60 })
throttle("stake_operations", { requests_per_minute: 10 })

// Cache validator scores
cache("validator_scores", { ttl: 30, strategy: "lru" })

// Modern protocol-based design for consensus with enhanced features
protocol ConsensusProtocol {
    action register_validator(address: string, stake: integer) -> boolean
    action deregister_validator(address: string) -> boolean
    action select_validator() -> string
    action validate_transaction(tx: any) -> boolean
    action validate_block(block: any) -> boolean
    action process_block_reward(validator: string, block: any) -> list
    action slash_validator(address: string, reason: string) -> boolean
    action get_consensus_state() -> map
}

contract PoSConsensus implements ConsensusProtocol {
    persistent storage validators: map
    persistent storage total_stake: integer = 0
    persistent storage block_reward: integer = 100
    persistent storage difficulty: integer = 1
    persistent storage epoch: integer = 0
    persistent storage slashed_validators: map
    persistent storage pending_rewards: map
    
    // Reactive state for consensus metrics
    watch validators {
        print("üë• Validators updated: " + string(len(validators)) + " active")
    }
    
    watch total_stake {
        print("üí∞ Total stake updated: " + string(total_stake))
    }

    // Enhanced Validator entity
    entity Validator {
        address: string
        stake: integer
        delegated_stake: integer = 0
        performance: float = 1.0
        last_active: integer?
        ai_trust_score: float = 1.0
        commission_rate: float = 0.0  // For delegation
        status: string = "active"  // active, jailed, slashed
        jail_release_block: integer?
        total_rewards: integer = 0
        total_slashed: integer = 0
        
        // Computed property
        get total_power() -> integer {
            return this.stake + this.delegated_stake
        }
        
        // Method for checking if validator can validate
        can_validate(current_block: integer) -> boolean {
            if this.status != "active" {
                return false
            }
            
            if this.jail_release_block != null and current_block <= this.jail_release_block {
                return false
            }
            
            return this.total_power >= CONSENSUS_POLICIES.min_stake
        }
    }

    action init() {
        this.validators = {}
        this.slashed_validators = {}
        this.pending_rewards = {}
        
        // Initialize database connection for persistent storage
        try {
            db.execute("""
                CREATE TABLE IF NOT EXISTS consensus_validators (
                    address VARCHAR(42) PRIMARY KEY,
                    stake BIGINT,
                    delegated_stake BIGINT DEFAULT 0,
                    performance FLOAT DEFAULT 1.0,
                    ai_trust_score FLOAT DEFAULT 1.0,
                    status VARCHAR(20) DEFAULT 'active',
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            """)
        } catch (error) {
            print("‚ö†Ô∏è Database initialization failed: " + error)
        }
    }

    action protect register_validator(address: string, stake: integer) -> boolean {
        // Input validation
        verify(len(address) == 42, "Invalid address length")
        verify(stake >= CONSENSUS_POLICIES.min_stake, "Stake below minimum requirement")
        verify(len(this.validators) < CONSENSUS_POLICIES.max_validators, "Maximum validators reached")
        
        if this.validators.has(address) {
            print("Validator already registered")
            return false
        }

        let validator = Validator{
            address: address,
            stake: stake,
            last_active: datetime.now().timestamp()
        }
        
        this.validators[address] = validator
        this.total_stake += stake
        
        // Store in database
        try {
            db.execute(
                "INSERT INTO consensus_validators (address, stake) VALUES (?, ?)",
                [address, stake]
            )
        } catch (error) {
            print("‚ö†Ô∏è Failed to save validator to database: " + error)
        }
        
        // Audit trail
        audit("validator_registered", {
            "address": address,
            "stake": stake,
            "timestamp": datetime.now().timestamp(),
            "total_validators": len(this.validators)
        })
        
        print("‚úÖ Validator registered: " + address + " with stake: " + string(stake))
        return true
    }

    action protect deregister_validator(address: string) -> boolean {
        verify(this.validators.has(address), "Validator not found")
        
        let validator = this.validators[address]
        
        // Check if validator has pending rewards
        if this.pending_rewards.has(address) {
            throw "Cannot deregister: pending rewards exist"
        }
        
        // Return stake (minus any slashing)
        let returned_stake = validator.stake - validator.total_slashed
        this.total_stake -= validator.stake
        
        // Remove from validators
        delete this.validators[address]
        
        // Update database
        try {
            db.execute(
                "UPDATE consensus_validators SET status = 'inactive' WHERE address = ?",
                [address]
            )
        } catch (error) {
            print("‚ö†Ô∏è Failed to update validator in database: " + error)
        }
        
        audit("validator_deregistered", {
            "address": address,
            "returned_stake": returned_stake,
            "total_slashed": validator.total_slashed,
            "timestamp": datetime.now().timestamp()
        })
        
        return true
    }

    action protect select_validator() -> string {
        if this.validators.is_empty() {
            throw "No validators available"
        }

        // Get cached scores if available
        let cached_scores = cache_get("validator_scores")
        if cached_scores != null {
            return this.select_from_cached_scores(cached_scores)
        }

        // Calculate weighted scores with AI trust factor
        let weighted_scores = []
        let total_weight = 0
        let current_block = this.get_current_block_number()

        for each address, validator in this.validators {
            if not validator.can_validate(current_block) {
                continue
            }
            
            let ai_score = this.ai_analyze_validator_performance(address)
            let weight = integer(validator.total_power * ai_score * validator.performance)
            weighted_scores.push({
                "address": address, 
                "weight": weight,
                "power": validator.total_power
            })
            total_weight += weight
        }

        if total_weight == 0 {
            return this.select_validator_fallback()
        }

        // Weighted random selection with stake consideration
        let random_value = math.random_int(0, total_weight - 1)
        let current_sum = 0

        for each item in weighted_scores {
            current_sum += item.weight
            if random_value < current_sum {
                this.update_validator_activity(item.address)
                return item.address
            }
        }

        return this.select_validator_fallback()
    }

    action select_from_cached_scores(scores: list) -> string {
        let total_weight = 0
        for each score in scores {
            total_weight += score.weight
        }
        
        if total_weight == 0 {
            return this.select_validator_fallback()
        }
        
        let random_value = math.random_int(0, total_weight - 1)
        let current_sum = 0
        
        for each score in scores {
            current_sum += score.weight
            if random_value < current_sum {
                this.update_validator_activity(score.address)
                return score.address
            }
        }
        
        return this.select_validator_fallback()
    }

    action update_validator_activity(address: string) {
        if this.validators.has(address) {
            // Get validator, modify, and reassign (Zexus 1.6.6 workaround)
            let validator = this.validators[address]
            validator.last_active = datetime.now().timestamp()
            validator.performance = math.min(1.0, validator.performance + 0.01)
            this.validators[address] = validator
        }
    }

    action select_validator_fallback() -> string {
        let highest_power = 0
        let selected_validator = ""

        for each address, validator in this.validators {
            if validator.total_power > highest_power {
                highest_power = validator.total_power
                selected_validator = address
            }
        }

        if selected_validator != "" {
            this.update_validator_activity(selected_validator)
            return selected_validator
        }

        throw "No validators available for selection"
    }

    action protect validate_transaction(tx: any) -> boolean {
        // Enhanced validation with security policies
        try {
            // Basic validation
            verify(tx.value >= 0, "Transaction value cannot be negative")
            verify(tx.from_addr != tx.to_addr, "Sender and receiver cannot be the same")
            verify(tx.gas_limit >= tx.gas_used, "Gas used cannot exceed gas limit")
            
            // Signature verification
            let tx_content = tx.from_addr + tx.to_addr + string(tx.value) + 
                            (tx.data ?? "") + string(tx.nonce)
            let tx_hash = crypto.keccak256(tx_content)
            
            let signature_valid = crypto.verify_signature(tx_hash, tx.signature, tx.from_addr)
            verify(signature_valid, "Invalid transaction signature")
            
            // Check nonce (simplified - in production would check against account nonce)
            verify(tx.nonce >= 0, "Invalid nonce")
            
            // Gas price validation (if EIP-1559)
            if tx.max_fee_per_gas != null {
                verify(tx.max_fee_per_gas > 0, "Max fee per gas must be positive")
                verify(tx.max_priority_fee_per_gas <= tx.max_fee_per_gas, 
                       "Priority fee cannot exceed max fee")
            }
            
            return true
            
        } catch (error) {
            print("‚ùå Transaction validation failed: " + error)
            audit("transaction_validation_failed", {
                "tx_hash": tx?.hash or "unknown",
                "error": error,
                "timestamp": datetime.now().timestamp()
            })
            return false
        }
    }

    action protect validate_block(block: any) -> boolean {
        try {
            verify(block != null, "Block cannot be null")
            verify(block.validator != null, "Block missing validator")
            verify(this.validators.has(block.validator), "Validator not registered")
            
            // Check if validator is active
            let validator = this.validators[block.validator]
            if not validator.can_validate(block.index) {
                throw "Validator cannot validate at this time"
            }
            
            // Validate block timestamp
            let current_time = datetime.now().timestamp()
            let time_diff = math.abs(current_time - block.timestamp)
            verify(time_diff <= 900, "Block timestamp too far from current time") // 15 minutes
            
            // Validate gas usage
            verify(block.gas_used <= block.gas_limit, "Gas used exceeds gas limit")
            
            // Validate transaction count
            verify(len(block.transactions) <= 1000, "Too many transactions in block")
            
            return true
            
        } catch (error) {
            print("‚ùå Block validation failed: " + error)
            return false
        }
    }

    action protect process_block_reward(validator: string, block: any) -> list {
        // Import Transaction entity from block module
        use "../core/block.zx" as block_module

        // Calculate reward with difficulty adjustment
        let base_reward = this.block_reward
        let difficulty_factor = this.difficulty / 1000.0  // Normalize
        let final_reward = integer(base_reward * (1.0 / difficulty_factor))
        
        let reward_data = {
            "type": "block_reward",
            "block_index": block.index,
            "validator": validator,
            "amount": final_reward,
            "difficulty": this.difficulty,
            "timestamp": datetime.now().timestamp()
        }

        let reward_tx = block_module.Transaction{
            hash: crypto.keccak256("reward_" + string(block.index) + validator + string(datetime.now().timestamp())),
            from_addr: "0x0000000000000000000000000000000000000000",
            to_addr: validator,
            value: final_reward,
            data: string(reward_data),
            gas_limit: 0,
            gas_used: 0,
            nonce: 0,
            signature: crypto.sign("system_reward", "system_private_key"),
            status: "confirmed",
            timestamp: datetime.now().timestamp()
        }

        // Store pending reward
        if not this.pending_rewards.has(validator) {
            this.pending_rewards[validator] = []
        }
        this.pending_rewards[validator].push({
            "block": block.index,
            "amount": final_reward,
            "timestamp": datetime.now().timestamp()
        })
        
        // Update validator rewards (Zexus 1.6.6 workaround)
        if this.validators.has(validator) {
            let validator_data = this.validators[validator]
            validator_data.total_rewards = validator_data.total_rewards + final_reward
            this.validators[validator] = validator_data
        }

        audit("block_reward_processed", reward_data)
        
        return [reward_tx]
    }

    action protect slash_validator(address: string, reason: string) -> boolean {
        verify(this.validators.has(address), "Validator not found")
        
        let validator = this.validators[address]
        let slash_amount = integer(validator.stake * CONSENSUS_POLICIES.slash_percentage)
        
        // Apply slashing
        validator.stake -= slash_amount
        validator.total_slashed += slash_amount
        validator.status = "slashed"
        this.total_stake -= slash_amount
        
        // Jail validator
        let current_block = this.get_current_block_number()
        validator.jail_release_block = current_block + 100  // Jail for 100 blocks
        
        audit("validator_slashed", {
            "address": address,
            "amount": slash_amount,
            "reason": reason,
            "release_block": validator.jail_release_block,
            "timestamp": datetime.now().timestamp()
        })
        
        // Update database
        try {
            db.execute(
                "UPDATE consensus_validators SET status = 'slashed', stake = stake - ? WHERE address = ?",
                [slash_amount, address]
            )
        } catch (error) {
            print("‚ö†Ô∏è Failed to update slashed validator in database: " + error)
        }
        
        return true
    }

    // Enhanced AI analysis with async support and database integration
    action async ai_analyze_validator_performance(validator: string) -> float {
        if not this.validators.has(validator) {
            return 0.0
        }

        let validator_data = this.validators[validator]
        
        // Try to get historical data from database
        let historical_data = null
        try {
            historical_data = db.query_one(
                "SELECT * FROM validator_performance WHERE address = ? ORDER BY timestamp DESC LIMIT 10",
                [validator]
            )
        } catch (error) {
            print("‚ö†Ô∏è Failed to fetch historical data: " + error)
        }

        // Factor 1: Stake amount (normalized)
        let stake_factor = math.min(1.0, validator_data.stake / 10000.0)

        // Factor 2: Recent activity with historical context
        let activity_factor = 1.0
        if validator_data.last_active != null {
            let time_diff = datetime.now().timestamp() - validator_data.last_active
            if time_diff > 3600 {
                activity_factor = math.max(0.1, 1.0 - (time_diff - 3600) / 86400.0)
            }
        }

        // Factor 3: Historical performance
        let performance_factor = validator_data.performance

        // Factor 4: AI trust score (self-correcting)
        let trust_factor = validator_data.ai_trust_score

        // Factor 5: Uptime from historical data
        let uptime_factor = 1.0
        if historical_data != null {
            let total_blocks = historical_data.total_blocks or 1
            let missed_blocks = historical_data.missed_blocks or 0
            uptime_factor = (total_blocks - missed_blocks) / total_blocks
        }

        // Combine factors with weights
        let final_score = (
            stake_factor * 0.3 +
            activity_factor * 0.2 +
            performance_factor * 0.2 +
            trust_factor * 0.2 +
            uptime_factor * 0.1
        )

        // Update the validator's AI trust score with smoothing
        let smoothing_factor = 0.1
        validator_data.ai_trust_score = (
            validator_data.ai_trust_score * (1 - smoothing_factor) + 
            final_score * smoothing_factor
        )

        return final_score
    }

    action async update_validator_scores_cache() {
        let scores = []
        for each address, validator in this.validators {
            let ai_score = await this.ai_analyze_validator_performance(address)
            let weight = integer(validator.total_power * ai_score)
            scores.push({"address": address, "weight": weight})
        }
        
        // Cache for 30 seconds
        cache_set("validator_scores", scores)
    }

    action get_validator_info(address: string) -> map? {
        if this.validators.has(address) {
            let validator = this.validators[address]
            return {
                "address": validator.address,
                "stake": validator.stake,
                "delegated_stake": validator.delegated_stake,
                "total_power": validator.total_power,
                "performance": validator.performance,
                "ai_trust_score": validator.ai_trust_score,
                "last_active": validator.last_active,
                "status": validator.status,
                "total_rewards": validator.total_rewards,
                "total_slashed": validator.total_slashed,
                "can_validate": validator.can_validate(this.get_current_block_number())
            }
        }
        return null
    }

    action get_consensus_state() -> map {
        let active_validators = 0
        let total_power = 0
        
        for each address, validator in this.validators {
            if validator.status == "active" {
                active_validators += 1
                total_power += validator.total_power
            }
        }
        
        return {
            "total_validators": len(this.validators),
            "active_validators": active_validators,
            "total_stake": this.total_stake,
            "total_power": total_power,
            "block_reward": this.block_reward,
            "difficulty": this.difficulty,
            "epoch": this.epoch,
            "slashed_validators": len(this.slashed_validators),
            "pending_rewards": len(this.pending_rewards)
        }
    }

    action get_consensus_stats() -> map {
        let state = this.get_consensus_state()
        
        // Add metrics
        state["average_stake"] = this.total_stake / math.max(1, len(this.validators))
        state["health_score"] = this.calculate_consensus_health()
        
        return state
    }
    
    action calculate_consensus_health() -> float {
        let active_count = 0
        for each address, validator in this.validators {
            if validator.status == "active" {
                active_count += 1
            }
        }
        
        let health = (active_count / math.max(1, len(this.validators))) * 100
        
        // Penalize for low stake diversity
        let stake_distribution = this.calculate_stake_distribution_score()
        health *= stake_distribution
        
        return math.min(100, health)
    }
    
    action calculate_stake_distribution_score() -> float {
        if len(this.validators) <= 1 {
            return 1.0
        }
        
        let stakes = []
        for each address, validator in this.validators {
            stakes.push(validator.total_power)
        }
        
        // Calculate Gini coefficient (simplified)
        let sorted_stakes = sort(stakes)
        let n = len(sorted_stakes)
        let total = sum(sorted_stakes)
        
        if total == 0 {
            return 1.0
        }
        
        let gini_numerator = 0
        for each i, stake in sorted_stakes {
            gini_numerator += (2 * i - n - 1) * stake
        }
        
        let gini = gini_numerator / (n * total)
        
        // Convert to distribution score (1.0 = perfect equality)
        return 1.0 - gini
    }
    
    action get_current_block_number() -> integer {
        // This would typically come from blockchain state
        // For now, return a simulated value
        return this.epoch * 100 + 50
    }

    // Dependency injection setup
    inject database: db
    
    // Middleware for consensus operations
    middleware("consensus_validation", action(req, res, next) {
        let operation = req["operation"]
        let validator = req["validator"]
        
        if operation in ["select_validator", "process_block_reward"] {
            // Rate limiting check
            if not security.check_rate_limit(validator, "consensus") {
                res["status"] = 429
                res["error"] = "Rate limit exceeded"
                return
            }
        }
        
        next()
    })
}

// Register consensus service for dependency injection
register_dependency("consensus_service", PoSConsensus())

// Test consensus with enhanced features
action async test_consensus_module() {
    print("‚öñÔ∏è Testing Enhanced Consensus Module v2.0...")
    
    // Enable error recovery
    continue
    
    try {
        let consensus = PoSConsensus()
        
        // Test validator registration
        let test_validator = "ZIV_test_validator_" + string(datetime.now().timestamp())
        
        if consensus.register_validator(test_validator, 5000) {
            print("‚úÖ Validator registered successfully")
            
            // Test validator selection
            let selected = consensus.select_validator()
            print("‚úÖ Selected validator: " + selected)
            
            // Test consensus state
            let stats = consensus.get_consensus_stats()
            print("üìä Consensus stats: " + string(stats))
            
            // Test validator info
            let validator_info = consensus.get_validator_info(test_validator)
            if validator_info != null {
                print("üë§ Validator info: " + string(validator_info))
            }
            
            // Test health calculation
            let health = consensus.calculate_consensus_health()
            print("üè• Consensus health: " + string(health) + "%")
            
            // Test slashing
            print("Testing slashing mechanism...")
            if consensus.slash_validator(test_validator, "test_slashing") {
                print("‚ö†Ô∏è Validator slashed (test)")
            }
        }
        
    } catch (error) {
        print("‚ùå Test failed: " + error)
    }
}

// Export for module use
export {
    PoSConsensus,
    ConsensusProtocol,
    CONSENSUS_POLICIES,
    test_consensus_module
}