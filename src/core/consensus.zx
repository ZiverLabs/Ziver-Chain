# src/core/consensus.zx
use "crypto" as crypto
use "datetime" as datetime
use "math" as math

// Modern protocol-based design for consensus
protocol ConsensusProtocol {
    action register_validator(address: string, stake: integer) -> boolean
    action select_validator() -> string
    action validate_transaction(tx: any) -> boolean
    action process_block_reward(validator: string, block: any) -> list
}

contract PoSConsensus implements ConsensusProtocol {
    persistent storage validators: map
    persistent storage total_stake: integer = 0
    persistent storage block_reward: integer = 100
    persistent storage difficulty: integer = 1

    action init() {
        this.validators = {}
    }

    entity Validator {
        address: string
        stake: integer
        performance: float = 1.0
        last_active: integer?
        ai_trust_score: float = 1.0
    }

    action register_validator(address: string, stake: integer) -> boolean {
        if this.validators.has(address) {
            print("Validator already registered")
            return false
        }

        let validator = Validator{
            address: address,
            stake: stake,
            last_active: datetime.now().timestamp()
        }
        this.validators[address] = validator
        this.total_stake += stake
        print("Validator registered: " + address + " with stake: " + string(stake))
        return true
    }

    action select_validator() -> string {
        if this.validators.is_empty() {
            throw "No validators available"
        }

        // Calculate weighted scores with AI trust factor
        let weighted_scores = []
        let total_weight = 0

        for each address, validator in this.validators {
            let ai_score = this.ai_analyze_validator_performance(address)
            let weight = integer(validator.stake * ai_score)
            weighted_scores.push({"address": address, "weight": weight})
            total_weight += weight
        }

        if total_weight == 0 {
            return this.select_validator_fallback()
        }

        // Weighted random selection
        let random_value = math.random_int(0, total_weight - 1)
        let current_sum = 0

        for each item in weighted_scores {
            current_sum += item.weight
            if random_value < current_sum {
                this.validators[item.address].last_active = datetime.now().timestamp()
                return item.address
            }
        }

        return this.select_validator_fallback()
    }

    action select_validator_fallback() -> string {
        let highest_stake = 0
        let selected_validator = ""

        for each address, validator in this.validators {
            if validator.stake > highest_stake {
                highest_stake = validator.stake
                selected_validator = address
            }
        }

        if selected_validator != "" {
            this.validators[selected_validator].last_active = datetime.now().timestamp()
            return selected_validator
        }

        throw "No validators available for selection"
    }

    action validate_transaction(tx: any) -> boolean {
        // Basic validation
        if tx.value < 0 {
            return false
        }

        if tx.from_addr == tx.to_addr {
            return false
        }

        if tx.gas_limit < tx.gas_used {
            return false
        }

        // Verify signature using transaction hash
        let tx_content = tx.from_addr + tx.to_addr + string(tx.value) + 
                        (tx.data ?? "") + string(tx.nonce)
        let tx_hash = crypto.keccak256(tx_content)

        let signature_valid = crypto.verify_signature(tx_hash, tx.signature, tx.from_addr)

        return signature_valid
    }

    action process_block_reward(validator: string, block: any) -> list {
        // Import Transaction entity from block module
        use "../core/block.zx" as block_module
        
        let reward_data = {
            "type": "block_reward",
            "block_index": block.index,
            "validator": validator,
            "amount": this.block_reward
        }

        let reward_tx = block_module.Transaction{
            hash: crypto.keccak256("reward_" + string(block.index) + validator),
            from_addr: "0x0000000000000000000000000000000000000000",
            to_addr: validator,
            value: this.block_reward,
            data: string(reward_data),
            gas_limit: 0,
            gas_used: 0,
            nonce: 0,
            signature: "system_reward",
            status: "confirmed"
        }

        return [reward_tx]
    }

    // Enhanced AI analysis with async support
    action async ai_analyze_validator_performance(validator: string) -> float {
        if not this.validators.has(validator) {
            return 0.0
        }

        let validator_data = this.validators[validator]

        // Factor 1: Stake amount (normalized)
        let stake_factor = math.min(1.0, validator_data.stake / 10000.0)

        // Factor 2: Recent activity
        let activity_factor = 1.0
        if validator_data.last_active != null {
            let time_diff = datetime.now().timestamp() - validator_data.last_active
            if time_diff > 3600 {
                activity_factor = math.max(0.1, 1.0 - (time_diff - 3600) / 86400.0)
            }
        }

        // Factor 3: Historical performance
        let performance_factor = validator_data.performance

        // Combine factors with weights
        let final_score = (stake_factor * 0.4) + (activity_factor * 0.3) + (performance_factor * 0.3)

        // Update the validator's AI trust score
        validator_data.ai_trust_score = final_score

        return final_score
    }

    action get_validator_info(address: string) -> map? {
        if this.validators.has(address) {
            let validator = this.validators[address]
            return {
                "address": validator.address,
                "stake": validator.stake,
                "performance": validator.performance,
                "ai_trust_score": validator.ai_trust_score,
                "last_active": validator.last_active
            }
        }
        return null
    }

    action get_consensus_stats() -> map {
        return {
            "total_validators": len(this.validators),
            "total_stake": this.total_stake,
            "block_reward": this.block_reward,
            "difficulty": this.difficulty
        }
    }
}

// Test consensus
action async test_consensus_module() {
    print("⚖️ Testing Consensus Module...")
    let consensus = PoSConsensus()
    let test_validator = "ZIV_test_validator_123"

    if consensus.register_validator(test_validator, 1000) {
        let selected = consensus.select_validator()
        print("Selected validator: " + selected)

        let stats = consensus.get_consensus_stats()
        print("Consensus stats: " + string(stats))

        let validator_info = consensus.get_validator_info(test_validator)
        if validator_info != null {
            print("Validator info: " + string(validator_info))
        }
    }
}

// Export for module use
export {
    PoSConsensus,
    ConsensusProtocol,
    test_consensus_module
}