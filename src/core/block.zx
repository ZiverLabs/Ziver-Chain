# src/core/block.zx
# Block and Transaction definitions for Ziver Chain
# Phase 0 rewrite — Zexus v1.8.2 compatible

use "crypto" as crypto
use "datetime" as dt

// ─── Constants ───

const BLOCK_SECURITY_POLICY = {
    "rate_limit": 100,
    "max_transactions": 1000,
    "max_block_size": 1048576,
    "allow_duplicate_txs": false
}

// ─── Entities ───

entity Block {
    index: 0,
    timestamp: 0,
    previous_hash: "",
    hash: "",
    merkle_root: "",
    transactions: [],
    validator: "",
    signature_val: "",
    nonce: 0,
    difficulty: 1,
    version: "2.0",
    gas_used: 0,
    gas_limit: 8000000,
    state_root: "",
    receipts_root: "",
    sealed: false
}

entity Transaction {
    hash: "",
    from_addr: "",
    to_addr: "",
    value: 0,
    data: "",
    gas_limit: 21000,
    gas_used: 0,
    nonce: 0,
    signature_val: "",
    status: "pending",
    timestamp: 0,
    fee: 0
}

entity BlockHeader {
    index: 0,
    hash: "",
    parent_hash: "",
    state_root: "",
    timestamp: 0,
    validator: ""
}

// ─── Helper functions (defined before use) ───

action double_keccak256(data) {
    let first = crypto.keccak256(data)
    return crypto.keccak256(first)
}

action calculate_merkle_root(hash_list) {
    if len(hash_list) == 0 {
        return crypto.keccak256("empty_merkle_root")
    }

    // Copy list
    let current = []
    for each h in hash_list {
        current.push(h)
    }

    while len(current) > 1 {
        let new_level = []
        let i = 0
        while i < len(current) {
            if i + 1 < len(current) {
                let combined = current[i] + current[i + 1]
                new_level.push(crypto.keccak256(combined))
                i = i + 2
            } else {
                // Odd element: duplicate
                let combined = current[i] + current[i]
                new_level.push(crypto.keccak256(combined))
                i = i + 1
            }
        }
        current = new_level
    }

    return current[0]
}

// ─── Block metrics ───

let block_metrics = {
    "total_blocks": 0,
    "total_transactions": 0,
    "average_block_time": 0,
    "last_block_timestamp": 0
}

action update_block_metrics(block) {
    block_metrics["total_blocks"] = block_metrics["total_blocks"] + 1
    block_metrics["total_transactions"] = block_metrics["total_transactions"] + len(block.transactions)

    let last_ts = block_metrics["last_block_timestamp"]
    if last_ts > 0 {
        let time_diff = block.timestamp - last_ts
        let prev_avg = block_metrics["average_block_time"]
        block_metrics["average_block_time"] = (prev_avg * 0.9) + (time_diff * 0.1)
    }

    block_metrics["last_block_timestamp"] = block.timestamp
}

action get_block_metrics() {
    return block_metrics
}

// ─── Genesis block creation ───

action create_genesis_block() {
    let timestamp = dt.timestamp()
    let genesis_data = "Ziver Chain Genesis Block v2.0 - AI-Enhanced Self-Evolving Blockchain"
    let merkle_root = crypto.keccak256(genesis_data)

    let content = "0" + string(timestamp) + "0" + merkle_root + "0" + "genesis" + "v2.0"
    let genesis_hash = double_keccak256(content)
    let state_root = crypto.keccak256("genesis_state_root")

    // Generate system keypair for genesis signing
    let system_kp = crypto.generateKeypair()
    let sig = signature("genesis", system_kp.private_key)

    let genesis = Block{
        index: 0,
        timestamp: timestamp,
        previous_hash: "0",
        hash: genesis_hash,
        merkle_root: merkle_root,
        transactions: [],
        validator: "0x0000000000000000000000000000000000000000",
        signature_val: sig,
        nonce: 0,
        difficulty: 1,
        version: "2.0",
        gas_used: 0,
        gas_limit: 8000000,
        state_root: state_root,
        receipts_root: "",
        sealed: true
    }

    audit("genesis_created", {
        "block_hash": genesis_hash,
        "timestamp": timestamp,
        "version": "2.0"
    })

    return genesis
}

// ─── Block creation ───

action create_block(previous_block, transactions, validator, private_key) {
    verify(previous_block != null, "Previous block cannot be null")
    verify(len(transactions) <= 1000, "Too many transactions")
    verify(validator != null, "Validator address required")

    let timestamp = dt.timestamp()

    // Collect tx hashes for merkle root
    let tx_hashes = []
    for each tx in transactions {
        verify(tx.hash != null, "Transaction missing hash")
        tx_hashes.push(tx.hash)
    }

    let merkle_root = calculate_merkle_root(tx_hashes)
    let state_root = crypto.keccak256(merkle_root + string(timestamp))

    // Build block hash
    let content = string(previous_block.index + 1) + string(timestamp) + previous_block.hash + merkle_root + validator + string(previous_block.difficulty) + state_root
    let block_hash = double_keccak256(content)

    // Sign the block
    let sig = signature(block_hash, private_key)

    // Calculate total gas
    let total_gas = 0
    for each tx in transactions {
        let tg = tx.gas_used
        if tg == null {
            tg = 0
        }
        total_gas = total_gas + tg
    }

    let new_block = Block{
        index: previous_block.index + 1,
        timestamp: timestamp,
        previous_hash: previous_block.hash,
        hash: block_hash,
        merkle_root: merkle_root,
        transactions: transactions,
        validator: validator,
        signature_val: sig,
        nonce: 0,
        difficulty: previous_block.difficulty,
        version: "2.0",
        gas_used: total_gas,
        gas_limit: 8000000,
        state_root: state_root,
        receipts_root: "",
        sealed: false
    }

    update_block_metrics(new_block)

    audit("block_created", {
        "index": new_block.index,
        "hash": new_block.hash,
        "validator": validator,
        "tx_count": len(transactions),
        "timestamp": timestamp
    })

    return new_block
}

// ─── Block validation ───

action validate_block(block, previous_block) {
    try {
        verify(block != null, "Block cannot be null")
        verify(previous_block != null, "Previous block cannot be null")

        if block.index != previous_block.index + 1 {
            throw "Block index mismatch"
        }

        if block.previous_hash != previous_block.hash {
            throw "Previous hash mismatch"
        }

        // Verify block hash
        let sr = block.state_root
        if sr == null {
            sr = ""
        }
        let content = string(block.index) + string(block.timestamp) + block.previous_hash + block.merkle_root + block.validator + string(block.difficulty) + sr
        let calculated_hash = double_keccak256(content)

        if calculated_hash != block.hash {
            throw "Block hash invalid"
        }

        // Verify merkle root (skip if cross-module entity field access issues)
        // TODO: re-enable once cross-module entity field access is fixed
        // let tx_hashes = []
        // for each tx in block.transactions {
        //     tx_hashes.push(tx.hash)
        // }
        // let calculated_merkle = calculate_merkle_root(tx_hashes)
        // if calculated_merkle != block.merkle_root {
        //     throw "Merkle root invalid"
        // }

        // Gas check
        if block.gas_used > block.gas_limit {
            throw "Gas used exceeds gas limit"
        }

        // Timestamp check
        let current_time = dt.timestamp()
        let time_diff = current_time - block.timestamp
        if time_diff < 0 {
            time_diff = 0 - time_diff
        }
        if time_diff > 900 {
            throw "Block timestamp too far from current time"
        }

        print("[block] Block #" + string(block.index) + " validated")
        return true

    } catch (error) {
        print("[block] Validation failed: " + string(error))
        return false
    }
}

// ─── Block sealing ───

action seal_block(block) {
    verify(block.sealed == false, "Block already sealed")

    let sealed = Block{
        index: block.index,
        timestamp: block.timestamp,
        previous_hash: block.previous_hash,
        hash: crypto.keccak256(block.hash + "_sealed_" + string(dt.timestamp())),
        merkle_root: block.merkle_root,
        transactions: block.transactions,
        validator: block.validator,
        signature_val: block.signature_val,
        nonce: block.nonce,
        difficulty: block.difficulty,
        version: block.version,
        gas_used: block.gas_used,
        gas_limit: block.gas_limit,
        state_root: block.state_root,
        receipts_root: block.receipts_root,
        sealed: true
    }

    return sealed
}

// ─── Batch validation ───

action validate_block_batch(blocks) {
    let results = []
    let valid_count = 0
    let i = 0

    while i < len(blocks) {
        let block = blocks[i]
        if i == 0 {
            results.push({ "index": block.index, "valid": true })
            valid_count = valid_count + 1
        } else {
            let prev = blocks[i - 1]
            let valid = validate_block(block, prev)
            results.push({ "index": block.index, "valid": valid })
            if valid {
                valid_count = valid_count + 1
            }
        }
        i = i + 1
    }

    print("[block] Batch: " + string(valid_count) + "/" + string(len(blocks)) + " valid")
    return results
}

// ─── Transaction creation helper ───

action create_transaction(from_addr, to_addr, value, private_key, nonce_val) {
    let timestamp = dt.timestamp()
    let tx_content = from_addr + to_addr + string(value) + string(nonce_val) + string(timestamp)
    let tx_hash = crypto.keccak256(tx_content)
    let sig = signature(tx_hash, private_key)

    let tx = Transaction{
        hash: tx_hash,
        from_addr: from_addr,
        to_addr: to_addr,
        value: value,
        data: "",
        gas_limit: 21000,
        gas_used: 21000,
        nonce: nonce_val,
        signature_val: sig,
        status: "pending",
        timestamp: timestamp,
        fee: 0
    }

    return tx
}

// ─── Test ───

action test_block_system() {
    print("=== Testing Block System v2.0 ===")

    try {
        let genesis = create_genesis_block()
        print("[OK] Genesis created - hash: " + genesis.hash)
        print("  index: " + string(genesis.index))
        print("  sealed: " + string(genesis.sealed))
        print("  version: " + genesis.version)

        // Create a transaction
        let kp = crypto.generateKeypair()
        let tx = create_transaction("0xABC", "0xDEF", 100, kp.private_key, 0)
        print("[OK] Transaction created - hash: " + tx.hash)

        // Create a block with the transaction
        let block1 = create_block(genesis, [tx], "0xVALIDATOR", kp.private_key)
        print("[OK] Block #1 created - hash: " + block1.hash)

        // Validate block
        let valid = validate_block(block1, genesis)
        print("[OK] Block #1 valid: " + string(valid))

        // Seal block
        let sealed = seal_block(block1)
        print("[OK] Block #1 sealed: " + string(sealed.sealed))

        // Metrics
        let metrics = get_block_metrics()
        print("[OK] Metrics: blocks=" + string(metrics["total_blocks"]))

        print("=== Block System Tests PASSED ===")

    } catch (error) {
        print("[FAIL] " + string(error))
    }
}

// ─── Exports ───

export {
    Block,
    Transaction,
    BlockHeader,
    BLOCK_SECURITY_POLICY,
    create_genesis_block,
    create_block,
    create_transaction,
    validate_block,
    seal_block,
    validate_block_batch,
    calculate_merkle_root,
    double_keccak256,
    get_block_metrics,
    update_block_metrics,
    test_block_system
}
