# src/core/block.zx
use "crypto" as crypto
use "datetime" as datetime

// Modern Zexus uses 'entity' for data structures, 'contract' for stateful
entity Block {
    index: integer
    timestamp: integer  
    previous_hash: string
    hash: string
    merkle_root: string
    transactions: list
    validator: string
    signature: string
    nonce: integer
    difficulty: integer
    version: string = "1.0"
}

entity Transaction {
    hash: string
    from_addr: string
    to_addr: string
    value: integer
    data: string?
    gas_limit: integer
    gas_used: integer
    nonce: integer
    signature: string
    status: string = "pending"
}

action create_genesis_block() -> Block {
    let timestamp = datetime.now().timestamp()
    let genesis_data = "Ziver Chain Genesis Block - The Self-Evolving Blockchain"

    // Create empty transactions list
    let empty_tx_list = []
    let merkle_root = crypto.keccak256(genesis_data)

    // Calculate genesis hash with proper string conversion
    let content = "0" + string(timestamp) + "0" + merkle_root + "0" + "genesis"
    let genesis_hash = crypto.keccak256(content)

    return Block{
        index: 0,
        timestamp: timestamp,
        previous_hash: "0",
        hash: genesis_hash,
        merkle_root: merkle_root,
        transactions: empty_tx_list,
        validator: "0x0000000000000000000000000000000000000000",
        signature: "genesis_signature",
        nonce: 0,
        difficulty: 1
    }
}

action create_block(previous_block: Block, transactions: list, validator: string, private_key: string) -> Block {
    let timestamp = datetime.now().timestamp()

    // Calculate merkle root from transactions
    let tx_hashes = []
    for each tx in transactions {
        tx_hashes.push(tx.hash)
    }
    let merkle_root = crypto.calculate_merkle_root(tx_hashes)

    // Create block content for hashing
    let content = string(previous_block.index + 1) + string(timestamp) + previous_block.hash + 
                  merkle_root + validator + string(previous_block.difficulty)
    let block_hash = crypto.keccak256(content)

    // Sign the block
    let signature = crypto.secp256k1_sign(block_hash, private_key)

    return Block{
        index: previous_block.index + 1,
        timestamp: timestamp,
        previous_hash: previous_block.hash,
        hash: block_hash,
        merkle_root: merkle_root,
        transactions: transactions,
        validator: validator,
        signature: signature,
        nonce: 0,
        difficulty: previous_block.difficulty
    }
}

action validate_block(block: Block, previous_block: Block) -> boolean {
    // Check block index continuity
    if block.index != previous_block.index + 1 {
        print("Block index mismatch")
        return false
    }

    // Check previous hash
    if block.previous_hash != previous_block.hash {
        print("Previous hash mismatch")
        return false
    }

    // Verify block hash
    let content = string(block.index) + string(block.timestamp) + block.previous_hash + 
                  block.merkle_root + block.validator + string(block.difficulty)
    let calculated_hash = crypto.keccak256(content)

    if calculated_hash != block.hash {
        print("Block hash invalid")
        return false
    }

    // Verify signature
    let signature_valid = crypto.verify_signature(block.hash, block.signature, block.validator)
    if not signature_valid {
        print("Block signature invalid")
        return false
    }

    // Verify merkle root
    let tx_hashes = []
    for each tx in block.transactions {
        tx_hashes.push(tx.hash)
    }
    let calculated_merkle = crypto.calculate_merkle_root(tx_hashes)
    if calculated_merkle != block.merkle_root {
        print("Merkle root invalid")
        return false
    }

    return true
}

// Test the block system
action async test_block_system() {
    print("ðŸ§± Testing Block System...")
    let genesis = create_genesis_block()
    print("Genesis Block Created:")
    print("  Hash: " + genesis.hash.slice(0, 16) + "...")
    print("  Index: " + string(genesis.index))
    print("  Valid: " + string(validate_block(genesis, genesis)))
}

// Export the functions properly
export {
    create_genesis_block,
    create_block, 
    validate_block,
    test_block_system,
    Block,
    Transaction
}