# src/core/block.zx
use { Crypto } from "./crypto.zx"

entity Block:
    index: integer
    timestamp: integer  
    previous_hash: text
    hash: text
    merkle_root: text
    transactions: List<Transaction>
    validator: Address
    signature: text
    nonce: integer
    difficulty: integer
    version: text = "1.0"

entity Transaction:
    hash: text
    from: Address
    to: Address
    value: integer
    data: text?
    gas_limit: integer
    gas_used: integer
    nonce: integer
    signature: text
    status: text = "pending"  # pending, confirmed, failed

action create_genesis_block() -> Block:
    let crypto = Crypto()
    let timestamp = DateTime.now().timestamp()
    let genesis_data = "Ziver Chain Genesis Block - The Self-Evolving Blockchain"
    
    # Create empty transactions list
    let empty_tx_list = []
    let merkle_root = crypto.calculate_merkle_root(empty_tx_list)
    
    # Calculate genesis hash
    let content = "0" + string(timestamp) + "0" + merkle_root + "0" + "genesis"
    let genesis_hash = crypto.hash_data(content)
    
    return Block(
        index: 0,
        timestamp: timestamp,
        previous_hash: "0",
        hash: genesis_hash,
        merkle_root: merkle_root,
        transactions: empty_tx_list,
        validator: "0x0000000000000000000000000000000000000000",
        signature: "genesis_signature",
        nonce: 0,
        difficulty: 1
    )

action create_block(previous_block: Block, transactions: List<Transaction>, validator: Address, private_key: text) -> Block:
    let crypto = Crypto()
    let timestamp = DateTime.now().timestamp()
    
    # Calculate merkle root from transactions
    let merkle_root = crypto.calculate_merkle_root(transactions)
    
    # Create block content for hashing
    let content = string(previous_block.index + 1) + string(timestamp) + previous_block.hash + merkle_root + validator + string(previous_block.difficulty)
    let block_hash = crypto.hash_data(content)
    
    # Sign the block
    let signature = crypto.sign_message(block_hash, private_key)
    
    return Block(
        index: previous_block.index + 1,
        timestamp: timestamp,
        previous_hash: previous_block.hash,
        hash: block_hash,
        merkle_root: merkle_root,
        transactions: transactions,
        validator: validator,
        signature: signature,
        nonce: 0,
        difficulty: previous_block.difficulty
    )

action validate_block(block: Block, previous_block: Block) -> boolean:
    let crypto = Crypto()
    
    # Check block index continuity
    if block.index != previous_block.index + 1:
        print "Block index mismatch"
        return false
    
    # Check previous hash
    if block.previous_hash != previous_block.hash:
        print "Previous hash mismatch"
        return false
    
    # Verify block hash
    let content = string(block.index) + string(block.timestamp) + block.previous_hash + block.merkle_root + block.validator + string(block.difficulty)
    let calculated_hash = crypto.hash_data(content)
    
    if calculated_hash != block.hash:
        print "Block hash invalid"
        return false
    
    # Verify signature
    let signature_valid = crypto.verify_signature(block.hash, block.signature, block.validator)
    if not signature_valid:
        print "Block signature invalid"
        return false
    
    # Verify merkle root
    let calculated_merkle = crypto.calculate_merkle_root(block.transactions)
    if calculated_merkle != block.merkle_root:
        print "Merkle root invalid"
        return false
    
    return true

# Test the block system
print "ðŸ§± Testing Block System..."
let genesis = create_genesis_block()
print "Genesis Block Created:"
print "  Hash: " + genesis.hash.slice(0, 16) + "..."
print "  Index: " + string(genesis.index)
print "  Valid: " + string(validate_block(genesis, genesis))  # Genesis validates itself