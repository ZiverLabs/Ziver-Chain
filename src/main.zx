# src/main.zx - UPDATED with Wallet & Contract Support
use { ZiverWallet } from "./contracts/wallet.zx"
use { CrossChainBridge } from "./contracts/bridge.zx"
use { ZRC20Token } from "./contracts/token_standard.zx"

entity ZiverNode:
    # ... (previous properties remain) ...
    wallet_contracts: Map<Address, ZiverWallet>
    bridge_manager: CrossChainBridge
    token_registry: Map<Address, ZRC20Token>
    
    action initialize():
        """
        Initialize with wallet and bridge support
        """
        print "üöÄ Initializing Ziver Node with Wallet Support..."
        
        # Initialize core components (from previous implementation)
        # ... (your existing initialization code) ...
        
        # Initialize wallet system
        self.bridge_manager = CrossChainBridge()
        
        print "‚úÖ Node initialized with multi-chain wallet support"
    
    action create_wallet(owner: Address) -> Address:
        """
        Deploy a new wallet contract for user
        """
        let wallet = ZiverWallet(owner)
        let wallet_address = "WALLET_" + crypto.hash_data(owner + string(DateTime.now().timestamp())).slice(0, 40)
        
        self.wallet_contracts[wallet_address] = wallet
        print "üëõ Wallet deployed: " + wallet_address + " for " + owner
        
        return wallet_address
    
    action deploy_token(name: text, symbol: text, supply: integer, owner: Address) -> Address:
        """
        Deploy a new ZRC-20 token
        """
        let token = ZRC20Token(name, symbol, supply, owner)
        let token_address = "TOKEN_" + crypto.hash_data(name + symbol + string(DateTime.now().timestamp())).slice(0, 40)
        
        self.token_registry[token_address] = token
        print "ü™ô Token deployed: " + name + " (" + symbol + ") at " + token_address
        
        return token_address
    
    action bridge_assets(wallet_address: Address, source_chain: text, target_chain: text, amount: integer, token_address: text?) -> boolean:
        """
        Bridge assets using the bridge manager
        """
        if not self.wallet_contracts.has(wallet_address):
            print "‚ùå Wallet not found"
            return false
        
        let wallet = self.wallet_contracts[wallet_address]
        
        # Use wallet's bridge function
        return wallet.bridge_assets(source_chain, target_chain, amount, token_address)
    
    action get_wallet_info(wallet_address: Address) -> Map<text, any>:
        """
        Get comprehensive wallet information
        """
        if not self.wallet_contracts.has(wallet_address):
            return {"error": "Wallet not found"}
        
        let wallet = self.wallet_contracts[wallet_address]
        let portfolio = wallet.get_total_portfolio_value()
        
        return {
            "owner": wallet.owner,
            "portfolio": portfolio,
            "supported_chains": wallet.supported_chains,
            "guardians": wallet.guardians.count()
        }

# Enhanced node startup
print "üèÅ Starting Enhanced Ziver Blockchain..."
let node = ZiverNode()
node.initialize()

# Test wallet creation
let user_wallet = node.create_wallet("ZIV_user_789")
let token_address = node.deploy_token("Ziver Gold", "ZGLD", 1000000, "ZIV_owner_123")

# Test wallet operations
let wallet_info = node.get_wallet_info(user_wallet)
print "üìä Wallet Info: " + string(wallet_info)

print "üéâ Phase 1B Complete! Multi-chain wallet system ready."