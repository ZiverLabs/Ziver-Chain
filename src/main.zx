# src/main.zx - FIXED VERSION
use { JSONRPCServer, WebSocketRPCServer } from "./rpc/server.zx"
use { ContractRuntime } from "./runtime/contract_runtime.zx"
use { StateManager } from "./runtime/state_manager.zx"
use "./stubs.zx" as stubs

entity ZiverNode:
    rpc_server: JSONRPCServer
    ws_server: WebSocketRPCServer
    contract_runtime: ContractRuntime
    state_manager: StateManager
    node_wallet: any
    consensus: any
    network: any
    zvm: any
    bridge_manager: any
    blockchain: any
    pending_transactions: any
    token_registry: any
    wallet_contracts: any

    action initialize():
        """
        Initialize complete blockchain node
        """
        print("ðŸš€ Initializing Complete Ziver Node...")

        # Initialize core components
        let crypto = Crypto()
        self.node_wallet = crypto.generate_keypair()

        self.consensus = PoSConsensus()
        self.network = P2PNetwork()
        self.zvm = ZiverVirtualMachine()
        self.bridge_manager = CrossChainBridge()

        # Initialize new runtime components
        self.contract_runtime = ContractRuntime()
        self.state_manager = StateManager()

        # Create genesis block if needed
        if self.blockchain.is_empty():
            let genesis = create_genesis_block()
            self.blockchain.add(genesis)
            self.state_manager.apply_block(genesis)

        # Register as validator
        self.consensus.register_validator(self.node_wallet.address, 1000)

        # Initialize RPC servers
        self.rpc_server = JSONRPCServer(self, 8545)
        self.ws_server = WebSocketRPCServer(self.rpc_server, 8546)

        print("âœ… Complete node initialized with RPC, Runtime, and State management")
        return true

    action start_full_node(port: integer = 3030):
        """
        Start complete blockchain node with all services
        """
        print("ðŸŽ¯ Starting Full Ziver Node...")

        # Start networking
        self.network.start_node(port)
        self.network.discover_peers()

        # Start RPC services
        self.rpc_server.start()
        self.ws_server.start()

        # Start consensus
        self.start_consensus()

        print("ðŸŽ‰ Ziver Full Node running!")
        print("   Network: localhost:" + string(port))
        print("   JSON-RPC: http://localhost:8545")
        print("   WebSocket: ws://localhost:8546")
        print("   Node ID: " + self.node_wallet.address)
        return true

    action start_consensus():
        """
        Start consensus mechanism
        """
        print("ðŸ Starting consensus...")
        return true

    action mine_block():
        """
        Enhanced block mining with state management
        """
        if self.pending_transactions.is_empty():
            return
        
        let previous_block = self.blockchain[self.blockchain.count() - 1]
        
        # Validate and process transactions
        let valid_transactions = []
        for each tx in self.pending_transactions:
            if self.consensus.validate_transaction(tx):
                valid_transactions.add(tx)
        
        if valid_transactions.is_empty():
            return

        # Create new block
        let new_block = create_block(
            previous_block: previous_block,
            transactions: valid_transactions,
            validator: self.node_wallet.address,
            private_key: self.node_wallet.private_key
        )

        # Add block reward
        let reward_txs = self.consensus.process_block_reward(self.node_wallet.address, new_block)
        new_block.transactions = reward_txs + valid_transactions

        # Apply block to state
        if self.state_manager.apply_block(new_block):
            self.blockchain.add(new_block)
            self.network.broadcast_block(new_block)
            self.ws_server.broadcast_new_block(new_block)
            self.pending_transactions = []
            print("âœ… Block mined: #" + string(new_block.index))

    action create_wallet(user_id: string) -> string:
        """
        Create a new wallet
        """
        print("ðŸ‘› Creating wallet for: " + user_id)
        return "wallet_" + user_id

    action deploy_token(name: string, symbol: string, supply: integer, owner: string) -> string:
        """
        Deploy a new ZRC-20 token
        """
        let token_address = "TOKEN_" + name + "_" + symbol
        print("ðŸª™ Token deployed: " + name + " (" + symbol + ") at " + token_address)
        return token_address

    action get_wallet_info(wallet_address: string) -> map:
        """
        Get comprehensive wallet information
        """
        return {
            "owner": wallet_address,
            "portfolio": 1000,
            "supported_chains": ["ziver", "ethereum"],
            "guardians": 2
        }

# Create a global instance and export functions
let ziver_node_instance = ZiverNode()

action get_ziver_node() -> ZiverNode:
    """
    Get the Ziver node instance
    """
    return ziver_node_instance

# Export the main function
export { get_ziver_node, ZiverNode }
