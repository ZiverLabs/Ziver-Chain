# DEFINITIVE TEST - What Actually Works
print("üéØ DEFINITIVE NESTED MAP UPDATE TEST")
print("=" * 70)

# =============================================================================
# Test 1: Module-Level Multiple Updates
# =============================================================================
print("\n‚úÖ Test 1: Module-level inline reconstruction (multiple updates)")

let validators = {}
validators["val_001"] = {"stake": 10000, "rewards": 0, "count": 0}

print("  Initial: stake=" + string(validators["val_001"]["stake"]) + ", rewards=" + string(validators["val_001"]["rewards"]) + ", count=" + string(validators["val_001"]["count"]))

# Update 1
validators["val_001"] = {
    "stake": validators["val_001"]["stake"],
    "rewards": validators["val_001"]["rewards"] + 100,
    "count": validators["val_001"]["count"] + 1
}
print("  Update 1: rewards=" + string(validators["val_001"]["rewards"]) + ", count=" + string(validators["val_001"]["count"]))

# Update 2
validators["val_001"] = {
    "stake": validators["val_001"]["stake"],
    "rewards": validators["val_001"]["rewards"] + 200,
    "count": validators["val_001"]["count"] + 1
}
print("  Update 2: rewards=" + string(validators["val_001"]["rewards"]) + ", count=" + string(validators["val_001"]["count"]))

# Update 3
validators["val_001"] = {
    "stake": validators["val_001"]["stake"],
    "rewards": validators["val_001"]["rewards"] + 300,
    "count": validators["val_001"]["count"] + 1
}
print("  Update 3: rewards=" + string(validators["val_001"]["rewards"]) + ", count=" + string(validators["val_001"]["count"]))

if validators["val_001"]["rewards"] == 600 and validators["val_001"]["count"] == 3 {
    print("  ‚úÖ Module-level multiple updates WORK!")
} else {
    print("  ‚ùå FAILED: Expected rewards=600, count=3")
}

# =============================================================================
# Test 2: Contract State Multiple Updates
# =============================================================================
print("\n‚úÖ Test 2: Contract state inline reconstruction (multiple updates)")

contract ValidatorRegistry {
    state validators = {}
    
    action register(address, stake) {
        validators[address] = {"stake": stake, "rewards": 0, "count": 0}
    }
    
    action add_reward(address, amount) {
        validators[address] = {
            "stake": validators[address]["stake"],
            "rewards": validators[address]["rewards"] + amount,
            "count": validators[address]["count"] + 1
        }
    }
    
    action get_validator(address) {
        if validators[address] != null {
            return validators[address]
        }
        return {"stake": 0, "rewards": 0, "count": 0}
    }
}

let registry = ValidatorRegistry()
registry.register("val_002", 15000)

let initial = registry.get_validator("val_002")
print("  Initial: stake=" + string(initial["stake"]) + ", rewards=" + string(initial["rewards"]))

registry.add_reward("val_002", 100)
let after1 = registry.get_validator("val_002")
print("  After reward 1: rewards=" + string(after1["rewards"]) + ", count=" + string(after1["count"]))

registry.add_reward("val_002", 200)
let after2 = registry.get_validator("val_002")
print("  After reward 2: rewards=" + string(after2["rewards"]) + ", count=" + string(after2["count"]))

registry.add_reward("val_002", 300)
let after3 = registry.get_validator("val_002")
print("  After reward 3: rewards=" + string(after3["rewards"]) + ", count=" + string(after3["count"]))

if after3["rewards"] == 600 and after3["count"] == 3 {
    print("  ‚úÖ Contract state multiple updates WORK!")
} else {
    print("  ‚ùå FAILED: Expected rewards=600, count=3, got rewards=" + string(after3["rewards"]) + ", count=" + string(after3["count"]))
}

# =============================================================================
# SUMMARY
# =============================================================================
print("\n" + "=" * 70)
print("üéâ FINAL VERDICT")
print("=" * 70)
print("\n‚úÖ THE INLINE RECONSTRUCTION PATTERN WORKS!")
print("\n   Pattern: map[key] = {field1: map[key]['field1'], field2: NEW_VALUE}")
print("\n   ‚úÖ Works at module level")
print("   ‚úÖ Works in contract state")
print("   ‚úÖ Works for multiple sequential updates")
print("\n‚ùå What DOESN'T work:")
print("   - map[key].field = value")
print("   - map[key]['field'] = value")  
print("   - let temp = map[key]; temp['field'] = val; map[key] = temp")
print("\nüìù THIS MEANS YOUR PRODUCTION FILES NEED REFACTORING!")
print("=" * 70)
