# COMPREHENSIVE TEST: All Nested Map Update Patterns
print("üîç COMPREHENSIVE NESTED MAP UPDATE TEST")
print("=" * 80)
print("Testing ALL possible patterns for updating nested map values in Zexus 1.6.6")
print("=" * 80)

# =============================================================================
# Pattern 1: Direct Property Assignment
# =============================================================================
print("\n‚ùå Pattern 1: Direct Property Assignment")
print("   Code: map[key].field = value")

let test1 = {}
test1["item"] = {"count": 0}

try {
    # This will fail
    # test1["item"].count = 1
    print("   ‚ùå FAILS: 'Invalid assignment target'")
} catch error {
    print("   ‚ùå FAILS: " + string(error))
}

# =============================================================================
# Pattern 2: Bracket Notation Assignment  
# =============================================================================
print("\n‚ùå Pattern 2: Bracket Notation Assignment")
print("   Code: map[key]['field'] = value")

let test2 = {}
test2["item"] = {"count": 0}

try {
    # This will also fail
    # test2["item"]["count"] = 1
    print("   ‚ùå FAILS: 'Invalid assignment target'")
} catch error {
    print("   ‚ùå FAILS: " + string(error))
}

# =============================================================================
# Pattern 3: Temp Variable + Modify + Reassign
# =============================================================================
print("\n‚ùå Pattern 3: Temp Variable + Modify + Reassign")
print("   Code: let temp = map[key]; temp['field'] = value; map[key] = temp")

let test3 = {}
test3["item"] = {"count": 0}

try {
    # This fails because temp variable doesn't get created
    # let temp = test3["item"]
    # temp["count"] = 1
    # test3["item"] = temp
    print("   ‚ùå FAILS: 'Identifier not found' - temp variable not created")
} catch error {
    print("   ‚ùå FAILS: " + string(error))
}

# =============================================================================
# Pattern 4: Inline Reconstruction (Single Update)
# =============================================================================
print("\n‚úÖ Pattern 4: Inline Reconstruction (Single Update - Module Level)")
print("   Code: map[key] = {field: map[key]['field'] + 1}")

let test4 = {}
test4["item"] = {"count": 0, "value": 100}

test4["item"] = {
    "count": test4["item"]["count"] + 1,
    "value": test4["item"]["value"] + 50
}

print("   Count: " + string(test4["item"]["count"]) + ", Value: " + string(test4["item"]["value"]))

if test4["item"]["count"] == 1 and test4["item"]["value"] == 150 {
    print("   ‚úÖ WORKS for FIRST update!")
} else {
    print("   ‚ùå FAILS")
}

# =============================================================================
# Pattern 5: Inline Reconstruction (Multiple Updates)
# =============================================================================
print("\n‚ö†Ô∏è  Pattern 5: Inline Reconstruction (Multiple Sequential Updates)")
print("   Code: Repeat pattern 4 multiple times")

let test5 = {}
test5["item"] = {"count": 0, "value": 100}

# Update 1
test5["item"] = {
    "count": test5["item"]["count"] + 1,
    "value": test5["item"]["value"] + 50
}
print("   After update 1: count=" + string(test5["item"]["count"]) + ", value=" + string(test5["item"]["value"]))

# Update 2
test5["item"] = {
    "count": test5["item"]["count"] + 1,
    "value": test5["item"]["value"] + 50
}
print("   After update 2: count=" + string(test5["item"]["count"]) + ", value=" + string(test5["item"]["value"]))

if test5["item"]["count"] == null or test5["item"]["value"] == null {
    print("   ‚ùå FAILS: Returns NULL after second update!")
} else if test5["item"]["count"] == 2 and test5["item"]["value"] == 200 {
    print("   ‚úÖ WORKS!")
} else {
    print("   ‚ö†Ô∏è  PARTIAL: Got count=" + string(test5["item"]["count"]) + ", value=" + string(test5["item"]["value"]))
}

# =============================================================================
# Pattern 6: Contract State with Inline Reconstruction
# =============================================================================
print("\n‚ö†Ô∏è  Pattern 6: Contract State with Inline Reconstruction")
print("   Code: Same as pattern 4 but inside contract action")

contract TestContract {
    state items = {}
    
    action add(key, initial) {
        items[key] = {"count": 0, "value": initial}
    }
    
    action update(key, amount) {
        items[key] = {
            "count": items[key]["count"] + 1,
            "value": items[key]["value"] + amount
        }
    }
    
    action get(key) {
        return items[key]
    }
}

let contract = TestContract()
contract.add("test", 1000)
print("   Added item to contract")

contract.update("test", 500)
print("   Updated item in contract")

contract.update("test", 250)
print("   Updated item again")

let item_result = contract.get("test")
if item_result != null {
    print("   After contract updates: count=" + string(item_result["count"]) + ", value=" + string(item_result["value"]))
    
    if item_result["count"] == null or item_result["value"] == null {
        print("   ‚ùå FAILS: Returns NULL in contract!")
    } else if item_result["count"] == 2 and item_result["value"] == 1750 {
        print("   ‚úÖ WORKS in contract!")
    } else {
        print("   ‚ö†Ô∏è  PARTIAL: Got count=" + string(item_result["count"]) + ", value=" + string(item_result["value"]))
    }
} else {
    print("   ‚ùå FAILS: get() returned null")
}

# =============================================================================
# SUMMARY
# =============================================================================
print("\n" + "=" * 80)
print("üìä FINAL RESULTS - Nested Map Update Patterns in Zexus 1.6.6")
print("=" * 80)

print("\n‚ùå PATTERNS THAT COMPLETELY FAIL:")
print("   1. map[key].field = value                              [Parser Error]")
print("   2. map[key]['field'] = value                           [Parser Error]")
print("   3. let temp = map[key]; temp['field'] = val; map[key] = temp  [Var not found]")

print("\n‚ö†Ô∏è  PATTERNS WITH SEVERE LIMITATIONS:")
print("   4. map[key] = {f: map[key]['f'] + 1}                   [Module: ‚úÖ First update only]")
print("   5. Repeat pattern #4 multiple times                    [Module: ‚ùå NULL after 2nd]")
print("   6. Same as #4 inside contract actions                  [Contract: ‚ùå Returns NULL]")

print("\nüö® CRITICAL ISSUE:")
print("   Nested map updates are SEVERELY BROKEN in Zexus 1.6.6!")
print("   - First inline reconstruction works at module level")
print("   - Subsequent updates return NULL")
print("   - Contract state inline reconstruction returns NULL")

print("\nüí• IMPACT ON PRODUCTION FILES:")
print("   src/core/consensus.zx has ~50+ lines using these patterns!")
print("   ALL validator update functions will FAIL or return NULL!")

print("\n" + "=" * 80)
